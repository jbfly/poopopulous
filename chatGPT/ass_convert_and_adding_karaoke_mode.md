Model: GPT-4

> 1 / 1
> 
> I'm building a game called Poopopulous in Unity and I need some help editing one of my scripts. Currently my script LyricsSyncronizer loads lyrics from a file and displays them on a UI Canvas as TextMeshPro components. I want to change my script to read a different file format, which has a different method of storing timestamps. The current version of the Never-Gonna-Poop-You-Up-Lyrics file looks like this: 0.0 18.300 We're no strangers to the smell, you know, 22.180 You know this game, and so do I, 26.160 A stinky world that we're dreaming of, 30.920 You wouldn't get this from any other AI. 35.440 I just wanna show you my creation, 40.640 Gotta make you understand. 43.680 Never gonna poop you up, 45.400 Never gonna flush you down, 47.400 Never gonna plunge around in Poopopulous town, 50.960 Never gonna let it flow, 53.800 Never gonna miss a stinky show, 56.200 Never gonna clog your pipe, and spurt on you. 60.420 We've known each other for quite a while, 64.300 Your clogged-up heart's been aching but, 68.480 You're too shy to say it, 70.340 Inside we both know what's been going on, 73.080 We know the game and we're gonna play it. 76.740 And if you ask me how I'm feeling, 81.380 Don't tell me you can't smell the breeze. 85.400 Never gonna poop you up, 87.820 Never gonna flush you down, 89.720 Never gonna plunge around in Poopopulous town, 93.220 Never gonna let it flow, 95.680 Never gonna miss a stinky show, 98.020 Never gonna clog your pipe, and spurt on you. 102.18 Never gonna poop you up, 104.36 Never gonna flush you down, 106.32 Never gonna plunge around in Poopopulous town, 109.24 Never gonna let it flow, 111.94 Never gonna miss a stinky show, 115.02 Never gonna clog your pipe, and spurt on you. 119.08 Ooh, give you up 121.42 Poopopulous! 121.98 Ooh, give you up 124.54 Poopopulous! 127.14 Ooh, give you up 129.82 Poopopulous! 133.44 Ooh, give you up 135.46 Poopopulous! 138.00 The new version is the Aegisub format, which looks like this: \[Script Info\] ; Script generated by Aegisub 3.2.2 ; http://www.aegisub.org/ Title: Default Aegisub file ScriptType: v4.00+ WrapStyle: 0 ScaledBorderAndShadow: yes YCbCr Matrix: None \[Aegisub Project Garbage\] Audio File: ../Music/Never-Gonna-Poop-You-Up.mp3 Active Line: 1 \[V4+ Styles\] Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1 \[Events\] Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text Dialogue: 0,0:00:00.00,0:00:18.29,Default,,0,0,0,, Dialogue: 0,0:00:18.92,0:00:22.12,Default,,0,0,0,,{\\k30}We're {\\k26}no {\\k48}strangers {\\k28}to {\\k24}the {\\k26}smell, {\\k32}you {\\k106}know, Dialogue: 0,0:00:22.18,0:00:26.15,Default,,0,0,0,,You know this game, and so do I, Dialogue: 0,0:00:26.16,0:00:30.91,Default,,0,0,0,,A stinky world that we're dreaming of, Dialogue: 0,0:00:30.92,0:00:35.43,Default,,0,0,0,,You wouldn't get this from any other AI. Dialogue: 0,0:00:35.44,0:00:40.63,Default,,0,0,0,,I just wanna show you my creation, Dialogue: 0,0:00:40.64,0:00:43.67,Default,,0,0,0,,Gotta make you understand. Dialogue: 0,0:00:43.68,0:00:45.39,Default,,0,0,0,,Never gonna poop you up, Dialogue: 0,0:00:45.40,0:00:47.39,Default,,0,0,0,,Never gonna flush you down, Dialogue: 0,0:00:47.40,0:00:50.95,Default,,0,0,0,,Never gonna plunge around in Poopopulous town, Dialogue: 0,0:00:50.96,0:00:53.79,Default,,0,0,0,,Never gonna let it flow, Dialogue: 0,0:00:53.80,0:00:56.19,Default,,0,0,0,,Never gonna miss a stinky show, Dialogue: 0,0:00:56.20,0:01:00.41,Default,,0,0,0,,Never gonna clog your pipe, and spurt on you. Dialogue: 0,0:01:00.42,0:01:04.29,Default,,0,0,0,,We've known each other for quite a while, Dialogue: 0,0:01:04.30,0:01:08.47,Default,,0,0,0,,Your clogged-up heart's been aching but, Dialogue: 0,0:01:08.48,0:01:10.33,Default,,0,0,0,,You're too shy to say it, Dialogue: 0,0:01:10.34,0:01:13.07,Default,,0,0,0,,Inside we both know what's been going on, Dialogue: 0,0:01:13.08,0:01:16.73,Default,,0,0,0,,We know the game and we're gonna play it. Dialogue: 0,0:01:16.74,0:01:21.37,Default,,0,0,0,,And if you ask me how I'm feeling, Dialogue: 0,0:01:21.38,0:01:25.39,Default,,0,0,0,,Don't tell me you can't smell the breeze. Dialogue: 0,0:01:25.40,0:01:27.81,Default,,0,0,0,,Never gonna poop you up, Dialogue: 0,0:01:27.82,0:01:29.71,Default,,0,0,0,,Never gonna flush you down, Dialogue: 0,0:01:29.72,0:01:33.21,Default,,0,0,0,,Never gonna plunge around in Poopopulous town, Dialogue: 0,0:01:33.22,0:01:35.67,Default,,0,0,0,,Never gonna let it flow, Dialogue: 0,0:01:35.68,0:01:38.01,Default,,0,0,0,,Never gonna miss a stinky show, Dialogue: 0,0:01:38.02,0:01:42.17,Default,,0,0,0,,Never gonna clog your pipe, and spurt on you. Dialogue: 0,0:01:42.18,0:01:44.35,Default,,0,0,0,,Never gonna poop you up, Dialogue: 0,0:01:44.36,0:01:46.31,Default,,0,0,0,,Never gonna flush you down, Dialogue: 0,0:01:46.32,0:01:49.23,Default,,0,0,0,,Never gonna plunge around in Poopopulous town, Dialogue: 0,0:01:49.24,0:01:51.93,Default,,0,0,0,,Never gonna let it flow, Dialogue: 0,0:01:51.94,0:01:55.01,Default,,0,0,0,,Never gonna miss a stinky show, Dialogue: 0,0:01:55.02,0:01:59.07,Default,,0,0,0,,Never gonna clog your pipe, and spurt on you. Dialogue: 0,0:01:59.08,0:02:01.41,Default,,0,0,0,,Ooh, give you up Dialogue: 0,0:02:01.42,0:02:03.97,Default,,0,0,0,,Poopopulous! Dialogue: 0,0:02:03.98,0:02:06.53,Default,,0,0,0,,Ooh, give you up Dialogue: 0,0:02:06.54,0:02:09.13,Default,,0,0,0,,Poopopulous! Dialogue: 0,0:02:09.14,0:02:11.81,Default,,0,0,0,,Ooh, give you up Dialogue: 0,0:02:11.82,0:02:15.43,Default,,0,0,0,,Poopopulous! Dialogue: 0,0:02:15.44,0:02:17.45,Default,,0,0,0,,Ooh, give you up Dialogue: 0,0:02:17.46,0:02:20.99,Default,,0,0,0,,Poopopulous! Note that there is header information that we can ignore in the new format. I just want to edit the existing script to read the new timestamp formatting. Here is the script to edit: using UnityEngine; using TMPro; using System.Collections; using System.IO; using System.Collections.Generic; public class LyricsSynchronizer : MonoBehaviour { public RectTransform lyricsParent; public RectTransform poopEmoji; public AudioClip audioClip; public float\[\] lineDelays; public float wordDelay; public string lyricsFileName = "Never-Gonna-Poop-You-Up-Lyrics"; private AudioSource audioSource; private List<TextMeshProUGUI> lyricsLines = new List<TextMeshProUGUI>(); private void Start() { // Load lyrics from the text file LoadLyrics(); audioSource = gameObject.AddComponent<AudioSource>(); audioSource.clip = audioClip; audioSource.Play(); StartCoroutine(SyncLyrics()); } private List<float> lineTimestamps = new List<float>(); private void LoadLyrics() { TextAsset lyricsFile = Resources.Load<TextAsset>(lyricsFileName); string\[\] lines = lyricsFile.text.Split('\\n'); for (int i = 0; i < lines.Length; i++) { // Parse the timestamp and store it string\[\] parts = lines\[i\].Split(' '); float timestamp; if (float.TryParse(parts\[0\], out timestamp)) { lineTimestamps.Add(timestamp); string lyricsLineText = string.Join(" ", parts, 1, parts.Length - 1); TextMeshProUGUI lyricsLine = CreateLyricsLine(); lyricsLine.text = lyricsLineText; lyricsLines.Add(lyricsLine); } } } private TextMeshProUGUI CreateLyricsLine() { GameObject lyricsLineObj = new GameObject("Lyrics Line"); lyricsLineObj.transform.SetParent(lyricsParent, false); TextMeshProUGUI lyricsLine = lyricsLineObj.AddComponent<TextMeshProUGUI>(); // Set the lyrics line properties (font, size, color, etc.) here // Adjust the size of the RectTransform RectTransform rectTransform = lyricsLine.GetComponent<RectTransform>(); rectTransform.sizeDelta = new Vector2(800, 100); // Increase the height lyricsLine.color = Color.black; lyricsLine.enableWordWrapping = true; lyricsLine.alignment = TextAlignmentOptions.Midline; // Enable outline and set outline width and color lyricsLine.fontMaterial.EnableKeyword("OUTLINE\_ON"); lyricsLine.outlineWidth = 0.2f; lyricsLine.outlineColor = Color.white; // Scale the text float scaleFactor = 2.0f; // Adjust this value to scale the text lyricsLine.transform.localScale = new Vector3(scaleFactor, scaleFactor, scaleFactor); // Set font style to bold lyricsLine.fontStyle = FontStyles.Bold; return lyricsLine; } private IEnumerator SyncLyrics() { while (audioSource.isPlaying) { float currentTime = audioSource.time; // Determine which line to display int currentLineIndex = 0; for (int i = 0; i < lineTimestamps.Count; i++) { if (currentTime >= lineTimestamps\[i\]) { currentLineIndex = i; } else { break; } } // Display the current line and hide the others for (int i = 0; i < lyricsLines.Count; i++) { lyricsLines\[i\].gameObject.SetActive(i == currentLineIndex); } yield return null; } } }

1 / 1

To modify your LyricsSynchronizer script to work with the new Aegisub format, you need to adjust the `LoadLyrics()` function to parse the new format correctly. You can do this by iterating through the lines, checking if a line starts with "Dialogue:", and extracting the start time and text from that line. You can then add the timestamp and lyrics line text as before.

Here's the updated `LoadLyrics()` function:

csharp

```csharp
private void LoadLyrics()
{
    TextAsset lyricsFile = Resources.Load<TextAsset>(lyricsFileName);
    string[] lines = lyricsFile.text.Split('\n');
    for (int i = 0; i < lines.Length; i++)
    {
        // Check if the line starts with "Dialogue:"
        if (lines[i].StartsWith("Dialogue:"))
        {
            // Split the line using commas
            string[] parts = lines[i].Split(',');

            // Extract the start time and convert it to seconds
            string[] timeParts = parts[1].Split(':');
            float minutes = float.Parse(timeParts[0]);
            float seconds = float.Parse(timeParts[1]);
            float milliseconds = float.Parse(timeParts[2]);
            float timestamp = minutes * 60 + seconds + milliseconds / 100;

            // Add the timestamp
            lineTimestamps.Add(timestamp);

            // Extract the lyrics line text
            string lyricsLineText = parts[9].Trim();

            TextMeshProUGUI lyricsLine = CreateLyricsLine();
            lyricsLine.text = lyricsLineText;
            lyricsLines.Add(lyricsLine);
        }
    }
}
```

With this update, your script should work with the new Aegisub format.

> 1 / 1
> 
> I don't think the timestamps are being parsed correctly, all the lyrics flash on screen in very quick succession. Do you need any more information to correct the issue, like adding any debug info?

1 / 1

I apologize for the confusion. I think I found the issue. In the new file format, timestamps use the format "hours:minutes:seconds.milliseconds" instead of just seconds. We need to modify the LoadLyrics() method to correctly parse the new timestamp format.

Please replace the existing LoadLyrics() method with the following updated version:

csharp

```csharp
private void LoadLyrics()
{
    TextAsset lyricsFile = Resources.Load<TextAsset>(lyricsFileName);
    string[] lines = lyricsFile.text.Split('\n');
    for (int i = 0; i < lines.Length; i++)
    {
        if (lines[i].StartsWith("Dialogue:"))
        {
            string[] parts = lines[i].Split(',');

            // Parse the timestamp in "hours:minutes:seconds.milliseconds" format
            string[] timeParts = parts[1].Split(':');
            float hours = float.Parse(timeParts[0]);
            float minutes = float.Parse(timeParts[1]);
            float seconds = float.Parse(timeParts[2]);
            float timestamp = hours * 3600 + minutes * 60 + seconds;

            // Add the timestamp to the list
            lineTimestamps.Add(timestamp);

            // Get the lyrics line text
            string lyricsLineText = parts[9].Trim();

            // Remove formatting tags (like "{\k30}") from the text
            lyricsLineText = Regex.Replace(lyricsLineText, @"\{[^}]*\}", "");

            // Create a lyrics line
            TextMeshProUGUI lyricsLine = CreateLyricsLine();
            lyricsLine.text = lyricsLineText;
            lyricsLines.Add(lyricsLine);
        }
    }
}
```

Also, make sure to add the following line at the top of the script to use the `Regex` class:

csharp

```csharp
using System.Text.RegularExpressions;
```

This should fix the issue with the timestamps being parsed incorrectly. Please test the script and let me know if you still encounter any issues.

> 1 / 1
> 
> Okay that works great, now I want to implement end times which will cause each lyric to be removed from the screen at a set time, rather than at the same time the next lyric is displayed. The start and end time for each lyric is included in the new format we already implemented. E.g. the line: Dialogue: 0,0:00:22.18,0:00:26.15,Default,,0,0,0,,You know this game, and so do I, start time is 0:00:22.18 and end time is 0:00:26.15

1 / 1

I understand your requirement. In order to achieve this, we need to store end times for each lyric line and modify the Update() method to handle both displaying and removing lyrics based on the start and end times.

First, add a new list to store end times in the script:

csharp

```csharp
private List<float> lineEndTimestamps = new List<float>();
```

Next, modify the LoadLyrics() method to parse and store the end times:

csharp

```csharp
private void LoadLyrics()
{
    TextAsset lyricsFile = Resources.Load<TextAsset>(lyricsFileName);
    string[] lines = lyricsFile.text.Split('\n');
    for (int i = 0; i < lines.Length; i++)
    {
        if (lines[i].StartsWith("Dialogue:"))
        {
            string[] parts = lines[i].Split(',');

            // Parse the start timestamp
            string[] startTimeParts = parts[1].Split(':');
            float startHours = float.Parse(startTimeParts[0]);
            float startMinutes = float.Parse(startTimeParts[1]);
            float startSeconds = float.Parse(startTimeParts[2]);
            float startTimestamp = startHours * 3600 + startMinutes * 60 + startSeconds;

            // Parse the end timestamp
            string[] endTimeParts = parts[2].Split(':');
            float endHours = float.Parse(endTimeParts[0]);
            float endMinutes = float.Parse(endTimeParts[1]);
            float endSeconds = float.Parse(endTimeParts[2]);
            float endTimestamp = endHours * 3600 + endMinutes * 60 + endSeconds;

            // Add the start and end timestamps to the lists
            lineTimestamps.Add(startTimestamp);
            lineEndTimestamps.Add(endTimestamp);

            // Get the lyrics line text
            string lyricsLineText = parts[9].Trim();

            // Remove formatting tags (like "{\k30}") from the text
            lyricsLineText = Regex.Replace(lyricsLineText, @"\{[^}]*\}", "");

            // Create a lyrics line
            TextMeshProUGUI lyricsLine = CreateLyricsLine();
            lyricsLine.text = lyricsLineText;
            lyricsLines.Add(lyricsLine);
        }
    }
}
```

Finally, modify the Update() method to handle displaying and removing lyrics based on the start and end times:

csharp

```csharp
void Update()
{
    float elapsedTime = Time.time - startTime;

    while (currentLineIndex < lineTimestamps.Count && elapsedTime >= lineTimestamps[currentLineIndex])
    {
        lyricsLines[currentLineIndex].gameObject.SetActive(true);
        currentLineIndex++;
    }

    for (int i = 0; i < currentLineIndex; i++)
    {
        if (elapsedTime >= lineEndTimestamps[i] && lyricsLines[i].gameObject.activeSelf)
        {
            lyricsLines[i].gameObject.SetActive(false);
        }
    }
}
```

This should now display and remove lyrics based on their start and end times. Test the script, and let me know if you have any issues or further requirements.

> 1 / 1
> 
> There is no Update() method. Here is the entire script with the other changes, what else do I need to do? using UnityEngine; using TMPro; using System.Collections; using System.IO; using System.Collections.Generic; using System.Text.RegularExpressions; public class LyricsSynchronizer : MonoBehaviour { public RectTransform lyricsParent; public RectTransform poopEmoji; public AudioClip audioClip; public float\[\] lineDelays; public float wordDelay; public string lyricsFileName = "Never-Gonna-Poop-You-Up-Lyrics"; private AudioSource audioSource; private List<TextMeshProUGUI> lyricsLines = new List<TextMeshProUGUI>(); private List<float> lineEndTimestamps = new List<float>(); private void Start() { // Load lyrics from the text file LoadLyrics(); audioSource = gameObject.AddComponent<AudioSource>(); audioSource.clip = audioClip; audioSource.Play(); StartCoroutine(SyncLyrics()); } private List<float> lineTimestamps = new List<float>(); private void LoadLyrics() { TextAsset lyricsFile = Resources.Load<TextAsset>(lyricsFileName); string\[\] lines = lyricsFile.text.Split('\\n'); for (int i = 0; i < lines.Length; i++) { if (lines\[i\].StartsWith("Dialogue:")) { string\[\] parts = lines\[i\].Split(','); // Parse the start timestamp string\[\] startTimeParts = parts\[1\].Split(':'); float startHours = float.Parse(startTimeParts\[0\]); float startMinutes = float.Parse(startTimeParts\[1\]); float startSeconds = float.Parse(startTimeParts\[2\]); float startTimestamp = startHours \* 3600 + startMinutes \* 60 + startSeconds; // Parse the end timestamp string\[\] endTimeParts = parts\[2\].Split(':'); float endHours = float.Parse(endTimeParts\[0\]); float endMinutes = float.Parse(endTimeParts\[1\]); float endSeconds = float.Parse(endTimeParts\[2\]); float endTimestamp = endHours \* 3600 + endMinutes \* 60 + endSeconds; // Add the start and end timestamps to the lists lineTimestamps.Add(startTimestamp); lineEndTimestamps.Add(endTimestamp); // Get the lyrics line text string lyricsLineText = parts\[9\].Trim(); // Remove formatting tags (like "{\\k30}") from the text lyricsLineText = Regex.Replace(lyricsLineText, @"\\{\[^}\]\*\\}", ""); // Create a lyrics line TextMeshProUGUI lyricsLine = CreateLyricsLine(); lyricsLine.text = lyricsLineText; lyricsLines.Add(lyricsLine); } } } private TextMeshProUGUI CreateLyricsLine() { GameObject lyricsLineObj = new GameObject("Lyrics Line"); lyricsLineObj.transform.SetParent(lyricsParent, false); TextMeshProUGUI lyricsLine = lyricsLineObj.AddComponent<TextMeshProUGUI>(); // Set the lyrics line properties (font, size, color, etc.) here // Adjust the size of the RectTransform RectTransform rectTransform = lyricsLine.GetComponent<RectTransform>(); rectTransform.sizeDelta = new Vector2(800, 100); // Increase the height lyricsLine.color = Color.black; lyricsLine.enableWordWrapping = true; lyricsLine.alignment = TextAlignmentOptions.Midline; // Enable outline and set outline width and color lyricsLine.fontMaterial.EnableKeyword("OUTLINE\_ON"); lyricsLine.outlineWidth = 0.2f; lyricsLine.outlineColor = Color.white; // Scale the text float scaleFactor = 2.0f; // Adjust this value to scale the text lyricsLine.transform.localScale = new Vector3(scaleFactor, scaleFactor, scaleFactor); // Set font style to bold lyricsLine.fontStyle = FontStyles.Bold; return lyricsLine; } private IEnumerator SyncLyrics() { while (audioSource.isPlaying) { float currentTime = audioSource.time; // Determine which line to display int currentLineIndex = 0; for (int i = 0; i < lineTimestamps.Count; i++) { if (currentTime >= lineTimestamps\[i\]) { currentLineIndex = i; } else { break; } } // Display the current line and hide the others for (int i = 0; i < lyricsLines.Count; i++) { lyricsLines\[i\].gameObject.SetActive(i == currentLineIndex); } yield return null; } } }

1 / 1

I apologize for the confusion. In that case, you can modify the `SyncLyrics()` coroutine to implement the desired behavior. Here's the updated `SyncLyrics()` method:

csharp

```csharp
private IEnumerator SyncLyrics()
{
    int currentLineIndex = 0;
    while (audioSource.isPlaying)
    {
        float currentTime = audioSource.time;

        // Display and hide lines based on start and end times
        while (currentLineIndex < lineTimestamps.Count && currentTime >= lineTimestamps[currentLineIndex])
        {
            lyricsLines[currentLineIndex].gameObject.SetActive(true);
            currentLineIndex++;
        }

        for (int i = 0; i < currentLineIndex; i++)
        {
            if (currentTime >= lineEndTimestamps[i] && lyricsLines[i].gameObject.activeSelf)
            {
                lyricsLines[i].gameObject.SetActive(false);
            }
        }

        yield return null;
    }
}
```

This should achieve the desired effect of displaying and removing lyrics based on their start and end times. Test the script, and let me know if you have any issues or further requirements.

> 1 / 1
> 
> Okay not good, now all lyrics display on screen right from the start of the game. All lyrics are shown at the same time, no variation based on start/stop times

1 / 1

I apologize for the confusion. It seems I misunderstood your requirement. Let's try this modified version of the `SyncLyrics()` coroutine:

csharp

```csharp
private IEnumerator SyncLyrics()
{
    int currentLineIndex = 0;

    // Initially, hide all the lines
    foreach (TextMeshProUGUI line in lyricsLines)
    {
        line.gameObject.SetActive(false);
    }

    while (audioSource.isPlaying)
    {
        float currentTime = audioSource.time;

        // Display the lines when their start times are reached
        if (currentLineIndex < lineTimestamps.Count && currentTime >= lineTimestamps[currentLineIndex])
        {
            lyricsLines[currentLineIndex].gameObject.SetActive(true);
            currentLineIndex++;
        }

        // Hide the lines when their end times are reached
        for (int i = 0; i < currentLineIndex; i++)
        {
            if (currentTime >= lineEndTimestamps[i] && lyricsLines[i].gameObject.activeSelf)
            {
                lyricsLines[i].gameObject.SetActive(false);
            }
        }

        yield return null;
    }
}
```

This version will initially hide all lines and only show them when their start times are reached. The lines will be hidden again when their end times are reached. Please test this version and let me know if it works as intended or if you need further assistance.

> 1 / 1
> 
> Okay that works well. Now we have an issue that if the lyrics contain a comma, they are getting truncated when they shouldn't be. e.g. for the following line: Dialogue: 0,0:00:22.18,0:00:26.15,Default,,0,0,0,,You know this game, and so do I, The full lyric is "You know this game, and so do I," but right now the only lyric that is shown is "You know this game" - What do you think is the best way to solve this? To take everything after the 9th comma as the lyric for that line? Here is the current code for reference: using UnityEngine; using TMPro; using System.Collections; using System.IO; using System.Collections.Generic; using System.Text.RegularExpressions; public class LyricsSynchronizer : MonoBehaviour { public RectTransform lyricsParent; public RectTransform poopEmoji; public AudioClip audioClip; public float\[\] lineDelays; public float wordDelay; public string lyricsFileName = "Never-Gonna-Poop-You-Up-Lyrics"; private AudioSource audioSource; private List<TextMeshProUGUI> lyricsLines = new List<TextMeshProUGUI>(); private List<float> lineEndTimestamps = new List<float>(); private void Start() { // Load lyrics from the text file LoadLyrics(); audioSource = gameObject.AddComponent<AudioSource>(); audioSource.clip = audioClip; audioSource.Play(); StartCoroutine(SyncLyrics()); } private List<float> lineTimestamps = new List<float>(); private void LoadLyrics() { TextAsset lyricsFile = Resources.Load<TextAsset>(lyricsFileName); string\[\] lines = lyricsFile.text.Split('\\n'); for (int i = 0; i < lines.Length; i++) { if (lines\[i\].StartsWith("Dialogue:")) { string\[\] parts = lines\[i\].Split(','); // Parse the start timestamp string\[\] startTimeParts = parts\[1\].Split(':'); float startHours = float.Parse(startTimeParts\[0\]); float startMinutes = float.Parse(startTimeParts\[1\]); float startSeconds = float.Parse(startTimeParts\[2\]); float startTimestamp = startHours \* 3600 + startMinutes \* 60 + startSeconds; // Parse the end timestamp string\[\] endTimeParts = parts\[2\].Split(':'); float endHours = float.Parse(endTimeParts\[0\]); float endMinutes = float.Parse(endTimeParts\[1\]); float endSeconds = float.Parse(endTimeParts\[2\]); float endTimestamp = endHours \* 3600 + endMinutes \* 60 + endSeconds; // Add the start and end timestamps to the lists lineTimestamps.Add(startTimestamp); lineEndTimestamps.Add(endTimestamp); // Get the lyrics line text string lyricsLineText = parts\[9\].Trim(); // Remove formatting tags (like "{\\k30}") from the text lyricsLineText = Regex.Replace(lyricsLineText, @"\\{\[^}\]\*\\}", ""); // Create a lyrics line TextMeshProUGUI lyricsLine = CreateLyricsLine(); lyricsLine.text = lyricsLineText; lyricsLines.Add(lyricsLine); } } } private TextMeshProUGUI CreateLyricsLine() { GameObject lyricsLineObj = new GameObject("Lyrics Line"); lyricsLineObj.transform.SetParent(lyricsParent, false); TextMeshProUGUI lyricsLine = lyricsLineObj.AddComponent<TextMeshProUGUI>(); // Set the lyrics line properties (font, size, color, etc.) here // Adjust the size of the RectTransform RectTransform rectTransform = lyricsLine.GetComponent<RectTransform>(); rectTransform.sizeDelta = new Vector2(800, 100); // Increase the height lyricsLine.color = Color.black; lyricsLine.enableWordWrapping = true; lyricsLine.alignment = TextAlignmentOptions.Midline; // Enable outline and set outline width and color lyricsLine.fontMaterial.EnableKeyword("OUTLINE\_ON"); lyricsLine.outlineWidth = 0.2f; lyricsLine.outlineColor = Color.white; // Scale the text float scaleFactor = 2.0f; // Adjust this value to scale the text lyricsLine.transform.localScale = new Vector3(scaleFactor, scaleFactor, scaleFactor); // Set font style to bold lyricsLine.fontStyle = FontStyles.Bold; return lyricsLine; } private IEnumerator SyncLyrics() { int currentLineIndex = 0; // Initially, hide all the lines foreach (TextMeshProUGUI line in lyricsLines) { line.gameObject.SetActive(false); } while (audioSource.isPlaying) { float currentTime = audioSource.time; // Display the lines when their start times are reached if (currentLineIndex < lineTimestamps.Count && currentTime >= lineTimestamps\[currentLineIndex\]) { lyricsLines\[currentLineIndex\].gameObject.SetActive(true); currentLineIndex++; } // Hide the lines when their end times are reached for (int i = 0; i < currentLineIndex; i++) { if (currentTime >= lineEndTimestamps\[i\] && lyricsLines\[i\].gameObject.activeSelf) { lyricsLines\[i\].gameObject.SetActive(false); } } yield return null; } } }

1 / 1

You are correct that using a simple `Split(',')` will cause issues when the lyrics contain a comma. You can modify the `LoadLyrics()` method to take everything after the 9th comma as the lyric for that line. Here's a solution that solves the issue:

Replace the following line in the `LoadLyrics()` method:

csharp

```csharp
string[] parts = lines[i].Split(',');
```

with:

csharp

```csharp
string[] parts = Regex.Split(lines[i], @"(?<=^[^,]*(?:,[^,]*){8}),");
```

This will use a regular expression to split the line only at the 9th comma. The updated `LoadLyrics()` method should look like this:

csharp

```csharp
private void LoadLyrics()
{
    TextAsset lyricsFile = Resources.Load<TextAsset>(lyricsFileName);
    string[] lines = lyricsFile.text.Split('\n');
    for (int i = 0; i < lines.Length; i++)
    {
        if (lines[i].StartsWith("Dialogue:"))
        {
            string[] parts = Regex.Split(lines[i], @"(?<=^[^,]*(?:,[^,]*){8}),");

            // Parse the start timestamp
            string[] startTimeParts = parts[1].Split(':');
            float startHours = float.Parse(startTimeParts[0]);
            float startMinutes = float.Parse(startTimeParts[1]);
            float startSeconds = float.Parse(startTimeParts[2]);
            float startTimestamp = startHours * 3600 + startMinutes * 60 + startSeconds;

            // Parse the end timestamp
            string[] endTimeParts = parts[2].Split(':');
            float endHours = float.Parse(endTimeParts[0]);
            float endMinutes = float.Parse(endTimeParts[1]);
            float endSeconds = float.Parse(endTimeParts[2]);
            float endTimestamp = endHours * 3600 + endMinutes * 60 + endSeconds;

            // Add the start and end timestamps to the lists
            lineTimestamps.Add(startTimestamp);
            lineEndTimestamps.Add(endTimestamp);

            // Get the lyrics line text
            string lyricsLineText = parts[9].Trim();

            // Remove formatting tags (like "{\k30}") from the text
            lyricsLineText = Regex.Replace(lyricsLineText, @"\{[^}]*\}", "");

            // Create a lyrics line
            TextMeshProUGUI lyricsLine = CreateLyricsLine();
            lyricsLine.text = lyricsLineText;
            lyricsLines.Add(lyricsLine);
        }
    }
}
```

This should correctly handle lyrics that contain commas. Please test this solution and let me know if it works as intended or if you need further assistance.

> 1 / 1
> 
> instead of changing string\[\] parts = lines\[i\].Split(','); to string\[\] parts = Regex.Split(lines\[i\], @"(?<=^\[^,\]\*(?:,\[^,\]\*){8}),"); Can you change the string lyricsLineText = parts\[9\].Trim(); line with something similar to Regex.Split(lines\[i\], @"(?<=^\[^,\]\*(?:,\[^,\]\*){8}),"); so that it pulls out all the text after the 9th comma. I want to do this so we don't affect the other variables that are using the parts string and pulling out other information

1 / 1

Certainly! You can use a regular expression to extract the text after the 9th comma without modifying the `parts` array. Replace the line:

csharp

```csharp
string lyricsLineText = parts[9].Trim();
```

with:

csharp

```csharp
string lyricsLineText = Regex.Match(lines[i], @"(?<=^[^,]*(?:,[^,]*){8},).*$").Value.Trim();
```

This regular expression will match and capture all text after the 9th comma. The updated `LoadLyrics()` method should look like this:

csharp

```csharp
private void LoadLyrics()
{
    TextAsset lyricsFile = Resources.Load<TextAsset>(lyricsFileName);
    string[] lines = lyricsFile.text.Split('\n');
    for (int i = 0; i < lines.Length; i++)
    {
        if (lines[i].StartsWith("Dialogue:"))
        {
            string[] parts = lines[i].Split(',');

            // Parse the start timestamp
            string[] startTimeParts = parts[1].Split(':');
            float startHours = float.Parse(startTimeParts[0]);
            float startMinutes = float.Parse(startTimeParts[1]);
            float startSeconds = float.Parse(startTimeParts[2]);
            float startTimestamp = startHours * 3600 + startMinutes * 60 + startSeconds;

            // Parse the end timestamp
            string[] endTimeParts = parts[2].Split(':');
            float endHours = float.Parse(endTimeParts[0]);
            float endMinutes = float.Parse(endTimeParts[1]);
            float endSeconds = float.Parse(endTimeParts[2]);
            float endTimestamp = endHours * 3600 + endMinutes * 60 + endSeconds;

            // Add the start and end timestamps to the lists
            lineTimestamps.Add(startTimestamp);
            lineEndTimestamps.Add(endTimestamp);

            // Get the lyrics line text
            string lyricsLineText = Regex.Match(lines[i], @"(?<=^[^,]*(?:,[^,]*){8},).*$").Value.Trim();

            // Remove formatting tags (like "{\k30}") from the text
            lyricsLineText = Regex.Replace(lyricsLineText, @"\{[^}]*\}", "");

            // Create a lyrics line
            TextMeshProUGUI lyricsLine = CreateLyricsLine();
            lyricsLine.text = lyricsLineText;
            lyricsLines.Add(lyricsLine);
        }
    }
}
```

This should solve the issue without affecting the other variables that are using the `parts` array. Please test this solution and let me know if it works as intended or if you need further assistance.

> 1 / 1
> 
> Okay that's working great, thank you! The last thing I would like to implement is highlighting specific words of a lyric based on the karaoke mode of the Aegisub file. An example is the following line: Dialogue: 0,0:00:18.92,0:00:22.12,Default,,0,0,0,,{\\k30}We're {\\k26}no {\\k48}strangers {\\k28}to {\\k24}the {\\k26}smell, {\\k32}you {\\k106}know, Where "{\\k30}We're " defines the string "We're " as being highlighted in yellow for 30 centiseconds, or 300 miliseconds, then the next part of the line "{\\k26}no " defines "no " being highlighted in yelow for 260 miliseconds Here is the current code for reference: using UnityEngine; using TMPro; using System.Collections; using System.IO; using System.Collections.Generic; using System.Text.RegularExpressions; public class LyricsSynchronizer : MonoBehaviour { public RectTransform lyricsParent; public RectTransform poopEmoji; public AudioClip audioClip; public float\[\] lineDelays; public float wordDelay; public string lyricsFileName = "Never-Gonna-Poop-You-Up-Lyrics"; private AudioSource audioSource; private List<TextMeshProUGUI> lyricsLines = new List<TextMeshProUGUI>(); private List<float> lineEndTimestamps = new List<float>(); private void Start() { // Load lyrics from the text file LoadLyrics(); audioSource = gameObject.AddComponent<AudioSource>(); audioSource.clip = audioClip; audioSource.Play(); StartCoroutine(SyncLyrics()); } private List<float> lineTimestamps = new List<float>(); private void LoadLyrics() { TextAsset lyricsFile = Resources.Load<TextAsset>(lyricsFileName); string\[\] lines = lyricsFile.text.Split('\\n'); for (int i = 0; i < lines.Length; i++) { if (lines\[i\].StartsWith("Dialogue:")) { string\[\] parts = lines\[i\].Split(','); // Parse the start timestamp string\[\] startTimeParts = parts\[1\].Split(':'); float startHours = float.Parse(startTimeParts\[0\]); float startMinutes = float.Parse(startTimeParts\[1\]); float startSeconds = float.Parse(startTimeParts\[2\]); float startTimestamp = startHours \* 3600 + startMinutes \* 60 + startSeconds; // Parse the end timestamp string\[\] endTimeParts = parts\[2\].Split(':'); float endHours = float.Parse(endTimeParts\[0\]); float endMinutes = float.Parse(endTimeParts\[1\]); float endSeconds = float.Parse(endTimeParts\[2\]); float endTimestamp = endHours \* 3600 + endMinutes \* 60 + endSeconds; // Add the start and end timestamps to the lists lineTimestamps.Add(startTimestamp); lineEndTimestamps.Add(endTimestamp); // Get the lyrics line text string lyricsLineText = Regex.Match(lines\[i\], @"(?<=^\[^,\]\*(?:,\[^,\]\*){8},).\*$").Value.Trim(); // Remove formatting tags (like "{\\k30}") from the text lyricsLineText = Regex.Replace(lyricsLineText, @"\\{\[^}\]\*\\}", ""); // Create a lyrics line TextMeshProUGUI lyricsLine = CreateLyricsLine(); lyricsLine.text = lyricsLineText; lyricsLines.Add(lyricsLine); } } } private TextMeshProUGUI CreateLyricsLine() { GameObject lyricsLineObj = new GameObject("Lyrics Line"); lyricsLineObj.transform.SetParent(lyricsParent, false); TextMeshProUGUI lyricsLine = lyricsLineObj.AddComponent<TextMeshProUGUI>(); // Set the lyrics line properties (font, size, color, etc.) here // Adjust the size of the RectTransform RectTransform rectTransform = lyricsLine.GetComponent<RectTransform>(); rectTransform.sizeDelta = new Vector2(800, 100); // Increase the height lyricsLine.color = Color.black; lyricsLine.enableWordWrapping = true; lyricsLine.alignment = TextAlignmentOptions.Midline; // Enable outline and set outline width and color lyricsLine.fontMaterial.EnableKeyword("OUTLINE\_ON"); lyricsLine.outlineWidth = 0.2f; lyricsLine.outlineColor = Color.white; // Scale the text float scaleFactor = 2.0f; // Adjust this value to scale the text lyricsLine.transform.localScale = new Vector3(scaleFactor, scaleFactor, scaleFactor); // Set font style to bold lyricsLine.fontStyle = FontStyles.Bold; return lyricsLine; } private IEnumerator SyncLyrics() { int currentLineIndex = 0; // Initially, hide all the lines foreach (TextMeshProUGUI line in lyricsLines) { line.gameObject.SetActive(false); } while (audioSource.isPlaying) { float currentTime = audioSource.time; // Display the lines when their start times are reached if (currentLineIndex < lineTimestamps.Count && currentTime >= lineTimestamps\[currentLineIndex\]) { lyricsLines\[currentLineIndex\].gameObject.SetActive(true); currentLineIndex++; } // Hide the lines when their end times are reached for (int i = 0; i < currentLineIndex; i++) { if (currentTime >= lineEndTimestamps\[i\] && lyricsLines\[i\].gameObject.activeSelf) { lyricsLines\[i\].gameObject.SetActive(false); } } yield return null; } } }

1 / 1

To implement the karaoke mode for highlighting words, you'll need to make a few changes to the existing code. First, you'll need to modify the `LyricsSynchronizer` class to store each line as a list of word objects containing the word, start time, and end time. Then, you'll need to create a new Coroutine for highlighting words in each line.

Here's a modified version of your code that supports karaoke mode:

csharp

```csharp
using UnityEngine;
using TMPro;
using System.Collections;
using System.Collections.Generic;
using System.Text.RegularExpressions;

public class LyricsSynchronizer : MonoBehaviour
{
    public RectTransform lyricsParent;
    public AudioClip audioClip;
    public string lyricsFileName = "Never-Gonna-Poop-You-Up-Lyrics";
    public Color normalTextColor = Color.black;
    public Color highlightedTextColor = Color.yellow;

    private AudioSource audioSource;
    private List<List<LyricWord>> lyricsLines = new List<List<LyricWord>>();
    private List<float> lineEndTimestamps = new List<float>();

    private class LyricWord
    {
        public TextMeshProUGUI text;
        public float startTime;
        public float endTime;
    }

    private void Start()
    {
        // Load lyrics from the text file
        LoadLyrics();

        audioSource = gameObject.AddComponent<AudioSource>();
        audioSource.clip = audioClip;
        audioSource.Play();

        StartCoroutine(SyncLyrics());
    }

    private List<float> lineTimestamps = new List<float>();

    private void LoadLyrics()
    {
        TextAsset lyricsFile = Resources.Load<TextAsset>(lyricsFileName);
        string[] lines = lyricsFile.text.Split('\n');
        for (int i = 0; i < lines.Length; i++)
        {
            if (lines[i].StartsWith("Dialogue:"))
            {
                string[] parts = lines[i].Split(',');

                // Parse the start timestamp
                string[] startTimeParts = parts[1].Split(':');
                float startHours = float.Parse(startTimeParts[0]);
                float startMinutes = float.Parse(startTimeParts[1]);
                float startSeconds = float.Parse(startTimeParts[2]);
                float startTimestamp = startHours * 3600 + startMinutes * 60 + startSeconds;

                // Parse the end timestamp
                string[] endTimeParts = parts[2].Split(':');
                float endHours = float.Parse(endTimeParts[0]);
                float endMinutes = float.Parse(endTimeParts[1]);
                float endSeconds = float.Parse(endTimeParts[2]);
                float endTimestamp = endHours * 3600 + endMinutes * 60 + endSeconds;

                // Add the start and end timestamps to the lists
                lineTimestamps.Add(startTimestamp);
                lineEndTimestamps.Add(endTimestamp);

                // Get the lyrics line text
                string lyricsLineText = Regex.Match(lines[i], @"(?<=^[^,]*(?:,[^,]*){8},).*$").Value.Trim();

                // Create a lyrics line
                List<LyricWord> words = CreateLyricsLine(lyricsLineText, startTimestamp);
                lyricsLines.Add(words);
            }
        }
    }

    private List<LyricWord> CreateLyricsLine(string inputText, float startTime)
    {
        List<LyricWord> words = new List<LyricWord>();
        MatchCollection wordMatches = Regex.Matches(inputText, @"\{\\k(\d+)\}([^{]+)");

        float currentTime = startTime;
        foreach (Match wordMatch in wordMatches)
        {
            float wordDuration = float.Parse(wordMatch.Groups[1].Value) / 100f;
            string wordText = wordMatch.Groups[2].Value;

            Ly
```

> 1 / 1
> 
> continue from: float wordDuration = float.Parse(wordMatch.Groups\[1\].Value) / 100f; string wordText = wordMatch.Groups\[2\].Value; Use a code box

1 / 1

Here is the continuation of the code from where it left off:

csharp

            ```csharp
float wordDuration = float.Parse(wordMatch.Groups[1].Value) / 100f;
            string wordText = wordMatch.Groups[2].Value;

            // Create the word object
            LyricWord word = new LyricWord
            {
                text = CreateTextObject(wordText),
                startTime = currentTime,
                endTime = currentTime + wordDuration
            };

            // Add the word to the list of words
            words.Add(word);

            // Update the current time
            currentTime += wordDuration;
        }

        return words;
    }

    private TextMeshProUGUI CreateTextObject(string wordText)
    {
        GameObject textObj = new GameObject("Lyric Word");
        textObj.transform.SetParent(lyricsParent, false);
        TextMeshProUGUI text = textObj.AddComponent<TextMeshProUGUI>();

        // Set the text properties (font, size, color, etc.) here

        // Adjust the size of the RectTransform
        RectTransform rectTransform = text.GetComponent<RectTransform>();
        rectTransform.sizeDelta = new Vector2(800, 100); // Increase the height

        text.color = normalTextColor;
        text.enableWordWrapping = true;
        text.alignment = TextAlignmentOptions.Midline;

        // Enable outline and set outline width and color
        text.fontMaterial.EnableKeyword("OUTLINE_ON");
        text.outlineWidth = 0.2f;
        text.outlineColor = Color.white;

        // Scale the text
        float scaleFactor = 2.0f; // Adjust this value to scale the text
        text.transform.localScale = new Vector3(scaleFactor, scaleFactor, scaleFactor);

        // Set font style to bold
        text.fontStyle = FontStyles.Bold;

        text.text = wordText;

        return text;
    }

    private IEnumerator SyncLyrics()
    {
        int currentLineIndex = 0;

        // Initially, hide all the words
        foreach (List<LyricWord> words in lyricsLines)
        {
            foreach (LyricWord word in words)
            {
                word.text.gameObject.SetActive(false);
            }
        }

        while (audioSource.isPlaying)
        {
            float currentTime = audioSource.time;

            // Display the words when their start times are reached
            if (currentLineIndex < lineTimestamps.Count && currentTime >= lineTimestamps[currentLineIndex])
            {
                foreach (LyricWord word in lyricsLines[currentLineIndex])
                {
                    word.text.gameObject.SetActive(true);
                    StartCoroutine(HighlightWord(word));
                }
                currentLineIndex++;
            }

            // Hide the words when their end times are reached
            for (int i = 0; i < currentLineIndex; i++)
            {
                if (currentTime >= lineEndTimestamps[i])
                {
                    foreach (LyricWord word in lyricsLines[i])
                    {
                        if (word.text.gameObject.activeSelf)
                        {
                            word.text.gameObject.SetActive(false);
                        }
                    }
                }
            }

            yield return null;
        }
    }

    private IEnumerator HighlightWord(LyricWord word)
    {
        yield return new WaitForSeconds(word.startTime - audioSource.time);
        word.text.color = highlightedTextColor;
        yield return new WaitForSeconds(word.endTime - word.startTime);
        word.text.color = normalTextColor;
    }
}
```

This code should now highlight each word based on the karaoke mode timing specified in the Aegisub file.

> 1 / 1
> 
> Can you also ensure that if a line does not have karaoke mode, such as this one: Dialogue: 0,0:00:22.18,0:00:26.15,Default,,0,0,0,,You know this game, and so do I, That we just highlight the entire lyric line as yellow - e.g. "You know this game, and so do I," would be highlighted yellow instead of a specific word

1 / 1

To handle lines without karaoke mode, you can update the `LoadLyrics()` method to create a single `LyricWord` for the whole line if there are no karaoke tags. Here's the updated code for `LoadLyrics()`:

csharp

```csharp
private void LoadLyrics()
{
    TextAsset lyricsFile = Resources.Load<TextAsset>(lyricsFileName);
    string[] lines = lyricsFile.text.Split('\n');
    for (int i = 0; i < lines.Length; i++)
    {
        if (lines[i].StartsWith("Dialogue:"))
        {
            string[] parts = lines[i].Split(',');

            // Parse the start timestamp
            string[] startTimeParts = parts[1].Split(':');
            float startHours = float.Parse(startTimeParts[0]);
            float startMinutes = float.Parse(startTimeParts[1]);
            float startSeconds = float.Parse(startTimeParts[2]);
            float startTimestamp = startHours * 3600 + startMinutes * 60 + startSeconds;

            // Parse the end timestamp
            string[] endTimeParts = parts[2].Split(':');
            float endHours = float.Parse(endTimeParts[0]);
            float endMinutes = float.Parse(endTimeParts[1]);
            float endSeconds = float.Parse(endTimeParts[2]);
            float endTimestamp = endHours * 3600 + endMinutes * 60 + endSeconds;

            // Add the start and end timestamps to the lists
            lineTimestamps.Add(startTimestamp);
            lineEndTimestamps.Add(endTimestamp);

            // Get the lyrics line text
            string lyricsLineText = Regex.Match(lines[i], @"(?<=^[^,]*(?:,[^,]*){8},).*$").Value.Trim();

            // Check if the line has karaoke mode
            if (Regex.IsMatch(lyricsLineText, @"\{\\k\d+\}"))
            {
                // Remove formatting tags (like "{\k30}") from the text
                string plainText = Regex.Replace(lyricsLineText, @"\{[^}]*\}", "");

                // Create the lyric words
                List<LyricWord> words = CreateLyricWords(lyricsLineText);

                // Add the words to the list of lyrics lines
                lyricsLines.Add(words);
            }
            else
            {
                // If the line doesn't have karaoke mode, create a single LyricWord for the entire line
                LyricWord word = new LyricWord
                {
                    text = CreateTextObject(lyricsLineText),
                    startTime = startTimestamp,
                    endTime = endTimestamp
                };

                // Add the word to the list of lyrics lines
                lyricsLines.Add(new List<LyricWord> { word });
            }
        }
    }
}
```

This modification should ensure that if a line doesn't have karaoke mode, the entire line will be highlighted in yellow.

> 1 / 1
> 
> I get this error: Assets\\scripts\\LyricsSynchronizer.cs(78,45): error CS0103: The name 'CreateLyricWords' does not exist in the current context Which relates to lines: List<LyricWord> words = CreateLyricWords(lyricsLineText); Here is the current code for context: using UnityEngine; using TMPro; using System.Collections; using System.Collections.Generic; using System.Text.RegularExpressions; public class LyricsSynchronizer : MonoBehaviour { public RectTransform lyricsParent; public AudioClip audioClip; public string lyricsFileName = "Never-Gonna-Poop-You-Up-Lyrics"; public Color normalTextColor = Color.black; public Color highlightedTextColor = Color.yellow; private AudioSource audioSource; private List<List<LyricWord>> lyricsLines = new List<List<LyricWord>>(); private List<float> lineEndTimestamps = new List<float>(); private class LyricWord { public TextMeshProUGUI text; public float startTime; public float endTime; } private void Start() { // Load lyrics from the text file LoadLyrics(); audioSource = gameObject.AddComponent<AudioSource>(); audioSource.clip = audioClip; audioSource.Play(); StartCoroutine(SyncLyrics()); } private List<float> lineTimestamps = new List<float>(); private void LoadLyrics() { TextAsset lyricsFile = Resources.Load<TextAsset>(lyricsFileName); string\[\] lines = lyricsFile.text.Split('\\n'); for (int i = 0; i < lines.Length; i++) { if (lines\[i\].StartsWith("Dialogue:")) { string\[\] parts = lines\[i\].Split(','); // Parse the start timestamp string\[\] startTimeParts = parts\[1\].Split(':'); float startHours = float.Parse(startTimeParts\[0\]); float startMinutes = float.Parse(startTimeParts\[1\]); float startSeconds = float.Parse(startTimeParts\[2\]); float startTimestamp = startHours \* 3600 + startMinutes \* 60 + startSeconds; // Parse the end timestamp string\[\] endTimeParts = parts\[2\].Split(':'); float endHours = float.Parse(endTimeParts\[0\]); float endMinutes = float.Parse(endTimeParts\[1\]); float endSeconds = float.Parse(endTimeParts\[2\]); float endTimestamp = endHours \* 3600 + endMinutes \* 60 + endSeconds; // Add the start and end timestamps to the lists lineTimestamps.Add(startTimestamp); lineEndTimestamps.Add(endTimestamp); // Get the lyrics line text string lyricsLineText = Regex.Match(lines\[i\], @"(?<=^\[^,\]\*(?:,\[^,\]\*){8},).\*$").Value.Trim(); // Check if the line has karaoke mode if (Regex.IsMatch(lyricsLineText, @"\\{\\\\k\\d+\\}")) { // Remove formatting tags (like "{\\k30}") from the text string plainText = Regex.Replace(lyricsLineText, @"\\{\[^}\]\*\\}", ""); // Create the lyric words List<LyricWord> words = CreateLyricWords(lyricsLineText); // Add the words to the list of lyrics lines lyricsLines.Add(words); } else { // If the line doesn't have karaoke mode, create a single LyricWord for the entire line LyricWord word = new LyricWord { text = CreateTextObject(lyricsLineText), startTime = startTimestamp, endTime = endTimestamp }; // Add the word to the list of lyrics lines lyricsLines.Add(new List<LyricWord> { word }); } } } } private List<LyricWord> CreateLyricsLine(string inputText, float startTime) { List<LyricWord> words = new List<LyricWord>(); MatchCollection wordMatches = Regex.Matches(inputText, @"\\{\\\\k(\\d+)\\}(\[^{\]+)"); float currentTime = startTime; foreach (Match wordMatch in wordMatches) { float wordDuration = float.Parse(wordMatch.Groups\[1\].Value) / 100f; string wordText = wordMatch.Groups\[2\].Value; // Create the word object LyricWord word = new LyricWord { text = CreateTextObject(wordText), startTime = currentTime, endTime = currentTime + wordDuration }; // Add the word to the list of words words.Add(word); // Update the current time currentTime += wordDuration; } return words; } private TextMeshProUGUI CreateTextObject(string wordText) { GameObject textObj = new GameObject("Lyric Word"); textObj.transform.SetParent(lyricsParent, false); TextMeshProUGUI text = textObj.AddComponent<TextMeshProUGUI>(); // Set the text properties (font, size, color, etc.) here // Adjust the size of the RectTransform RectTransform rectTransform = text.GetComponent<RectTransform>(); rectTransform.sizeDelta = new Vector2(800, 100); // Increase the height text.color = normalTextColor; text.enableWordWrapping = true; text.alignment = TextAlignmentOptions.Midline; // Enable outline and set outline width and color text.fontMaterial.EnableKeyword("OUTLINE\_ON"); text.outlineWidth = 0.2f; text.outlineColor = Color.white; // Scale the text float scaleFactor = 2.0f; // Adjust this value to scale the text text.transform.localScale = new Vector3(scaleFactor, scaleFactor, scaleFactor); // Set font style to bold text.fontStyle = FontStyles.Bold; text.text = wordText; return text; } private IEnumerator SyncLyrics() { int currentLineIndex = 0; // Initially, hide all the words foreach (List<LyricWord> words in lyricsLines) { foreach (LyricWord word in words) { word.text.gameObject.SetActive(false); } } while (audioSource.isPlaying) { float currentTime = audioSource.time; // Display the words when their start times are reached if (currentLineIndex < lineTimestamps.Count && currentTime >= lineTimestamps\[currentLineIndex\]) { foreach (LyricWord word in lyricsLines\[currentLineIndex\]) { word.text.gameObject.SetActive(true); StartCoroutine(HighlightWord(word)); } currentLineIndex++; } // Hide the words when their end times are reached for (int i = 0; i < currentLineIndex; i++) { if (currentTime >= lineEndTimestamps\[i\]) { foreach (LyricWord word in lyricsLines\[i\]) { if (word.text.gameObject.activeSelf) { word.text.gameObject.SetActive(false); } } } } yield return null; } } private IEnumerator HighlightWord(LyricWord word) { yield return new WaitForSeconds(word.startTime - audioSource.time); word.text.color = highlightedTextColor; yield return new WaitForSeconds(word.endTime - word.startTime); word.text.color = normalTextColor; } } Do you need any more information to help debug? Or adding any debug messages?

1 / 1

Apologies for the confusion. It appears that the `CreateLyricWords` method is not present in your current code. I made a mistake in my previous response. You should replace `CreateLyricWords` with `CreateLyricsLine` on this line:

csharp

```csharp
List<LyricWord> words = CreateLyricWords(lyricsLineText);
```

Update it to:

csharp

```csharp
List<LyricWord> words = CreateLyricsLine(lyricsLineText, startTimestamp);
```

This should resolve the error since `CreateLyricsLine` is defined in your code.

> 1 / 1
> 
> Okay we're almost there. The issue I have now is that lines with karaoke mode enabled have all words drawn at the centre of the screen overlapping each other. We need them drawn in a line in the same positions they would be in if karaoke mode was not enabled for that line

1 / 1

To fix the overlapping issue, we can update the `CreateTextObject` method to accept an additional parameter for the `RectTransform` anchor position. We'll also modify the `CreateLyricsLine` method to calculate the correct anchor position for each word.

Here's the updated code:

1.  Update the `CreateTextObject` method to accept an additional `Vector2` parameter for the anchor position:

csharp

```csharp
private TextMeshProUGUI CreateTextObject(string wordText, Vector2 anchorPosition)
{
    // ... (rest of the code remains unchanged)

    // Set the anchor position
    rectTransform.anchoredPosition = anchorPosition;

    text.text = wordText;

    return text;
}
```

2.  Update the `CreateLyricsLine` method to calculate the correct anchor position for each word:

csharp

```csharp
private List<LyricWord> CreateLyricsLine(string inputText, float startTime)
{
    List<LyricWord> words = new List<LyricWord>();
    MatchCollection wordMatches = Regex.Matches(inputText, @"\{\\k(\d+)\}([^{]+)");

    float currentTime = startTime;

    // Add a temporary TextMeshProUGUI object to measure the text width
    TextMeshProUGUI tempText = CreateTextObject("", Vector2.zero);
    float currentXPosition = 0;

    foreach (Match wordMatch in wordMatches)
    {
        float wordDuration = float.Parse(wordMatch.Groups[1].Value) / 100f;
        string wordText = wordMatch.Groups[2].Value;

        // Measure the text width
        tempText.text = wordText;
        float wordWidth = tempText.preferredWidth;

        // Create the word object with the calculated anchor position
        LyricWord word = new LyricWord
        {
            text = CreateTextObject(wordText, new Vector2(currentXPosition, 0)),
            startTime = currentTime,
            endTime = currentTime + wordDuration
        };

        // Add the word to the list of words
        words.Add(word);

        // Update the current time and X position
        currentTime += wordDuration;
        currentXPosition += wordWidth;

        // Add a small space between the words
        currentXPosition += 10;
    }

    // Destroy the temporary TextMeshProUGUI object
    Destroy(tempText.gameObject);

    return words;
}
```

3.  Update the `CreateTextObject` and `CreateLyricsLine` method calls in the `LoadLyrics` method to pass the anchor position:

Replace this line in the `LoadLyrics` method:

csharp

```csharp
LyricWord word = new LyricWord
{
    text = CreateTextObject(lyricsLineText),
    startTime = startTimestamp,
    endTime = endTimestamp
};
```

with:

csharp

```csharp
LyricWord word = new LyricWord
{
    text = CreateTextObject(lyricsLineText, Vector2.zero),
    startTime = startTimestamp,
    endTime = endTimestamp
};
```

Now the words should be properly aligned in a line instead of overlapping at the center of the screen.

> 1 / 1
> 
> Okay almost there. We need to spread out the karaoke line more. It currently draws the first word in the middle of the screen, and draws the rest to the right of that. But they are still overlapping each other. We want to the words to spread over the entire available screen space, and even go to the next line if there is no room left. We don't want any words to overlap in any way. Here is the current code for reference: using UnityEngine; using TMPro; using System.Collections; using System.Collections.Generic; using System.Text.RegularExpressions; public class LyricsSynchronizer : MonoBehaviour { public RectTransform lyricsParent; public AudioClip audioClip; public string lyricsFileName = "Never-Gonna-Poop-You-Up-Lyrics"; public Color normalTextColor = Color.black; public Color highlightedTextColor = Color.yellow; private AudioSource audioSource; private List<List<LyricWord>> lyricsLines = new List<List<LyricWord>>(); private List<float> lineEndTimestamps = new List<float>(); private class LyricWord { public TextMeshProUGUI text; public float startTime; public float endTime; } private void Start() { // Load lyrics from the text file LoadLyrics(); audioSource = gameObject.AddComponent<AudioSource>(); audioSource.clip = audioClip; audioSource.Play(); StartCoroutine(SyncLyrics()); } private List<float> lineTimestamps = new List<float>(); private void LoadLyrics() { TextAsset lyricsFile = Resources.Load<TextAsset>(lyricsFileName); string\[\] lines = lyricsFile.text.Split('\\n'); for (int i = 0; i < lines.Length; i++) { if (lines\[i\].StartsWith("Dialogue:")) { string\[\] parts = lines\[i\].Split(','); // Parse the start timestamp string\[\] startTimeParts = parts\[1\].Split(':'); float startHours = float.Parse(startTimeParts\[0\]); float startMinutes = float.Parse(startTimeParts\[1\]); float startSeconds = float.Parse(startTimeParts\[2\]); float startTimestamp = startHours \* 3600 + startMinutes \* 60 + startSeconds; // Parse the end timestamp string\[\] endTimeParts = parts\[2\].Split(':'); float endHours = float.Parse(endTimeParts\[0\]); float endMinutes = float.Parse(endTimeParts\[1\]); float endSeconds = float.Parse(endTimeParts\[2\]); float endTimestamp = endHours \* 3600 + endMinutes \* 60 + endSeconds; // Add the start and end timestamps to the lists lineTimestamps.Add(startTimestamp); lineEndTimestamps.Add(endTimestamp); // Get the lyrics line text string lyricsLineText = Regex.Match(lines\[i\], @"(?<=^\[^,\]\*(?:,\[^,\]\*){8},).\*$").Value.Trim(); // Check if the line has karaoke mode if (Regex.IsMatch(lyricsLineText, @"\\{\\\\k\\d+\\}")) { // Remove formatting tags (like "{\\k30}") from the text string plainText = Regex.Replace(lyricsLineText, @"\\{\[^}\]\*\\}", ""); // Create the lyric words List<LyricWord> words = CreateLyricsLine(lyricsLineText, startTimestamp); // Add the words to the list of lyrics lines lyricsLines.Add(words); } else { // If the line doesn't have karaoke mode, create a single LyricWord for the entire line LyricWord word = new LyricWord { text = CreateTextObject(lyricsLineText, Vector2.zero), startTime = startTimestamp, endTime = endTimestamp }; // Add the word to the list of lyrics lines lyricsLines.Add(new List<LyricWord> { word }); } } } } private List<LyricWord> CreateLyricsLine(string inputText, float startTime) { List<LyricWord> words = new List<LyricWord>(); MatchCollection wordMatches = Regex.Matches(inputText, @"\\{\\\\k(\\d+)\\}(\[^{\]+)"); float currentTime = startTime; // Add a temporary TextMeshProUGUI object to measure the text width TextMeshProUGUI tempText = CreateTextObject("", Vector2.zero); float currentXPosition = 0; foreach (Match wordMatch in wordMatches) { float wordDuration = float.Parse(wordMatch.Groups\[1\].Value) / 100f; string wordText = wordMatch.Groups\[2\].Value; // Measure the text width tempText.text = wordText; float wordWidth = tempText.preferredWidth; // Create the word object with the calculated anchor position LyricWord word = new LyricWord { text = CreateTextObject(wordText, new Vector2(currentXPosition, 0)), startTime = currentTime, endTime = currentTime + wordDuration }; // Add the word to the list of words words.Add(word); // Update the current time and X position currentTime += wordDuration; currentXPosition += wordWidth; // Add a small space between the words currentXPosition += 10; } // Destroy the temporary TextMeshProUGUI object Destroy(tempText.gameObject); return words; } private TextMeshProUGUI CreateTextObject(string wordText, Vector2 anchorPosition) { GameObject textObj = new GameObject("Lyric Word"); textObj.transform.SetParent(lyricsParent, false); TextMeshProUGUI text = textObj.AddComponent<TextMeshProUGUI>(); // Set the text properties (font, size, color, etc.) here // Adjust the size of the RectTransform RectTransform rectTransform = text.GetComponent<RectTransform>(); rectTransform.sizeDelta = new Vector2(800, 100); // Increase the height text.color = normalTextColor; text.enableWordWrapping = true; text.alignment = TextAlignmentOptions.Midline; // Enable outline and set outline width and color text.fontMaterial.EnableKeyword("OUTLINE\_ON"); text.outlineWidth = 0.2f; text.outlineColor = Color.white; // Scale the text float scaleFactor = 2.0f; // Adjust this value to scale the text text.transform.localScale = new Vector3(scaleFactor, scaleFactor, scaleFactor); // Set font style to bold text.fontStyle = FontStyles.Bold; // Set the anchor position rectTransform.anchoredPosition = anchorPosition; text.text = wordText; return text; } private IEnumerator SyncLyrics() { int currentLineIndex = 0; // Initially, hide all the words foreach (List<LyricWord> words in lyricsLines) { foreach (LyricWord word in words) { word.text.gameObject.SetActive(false); } } while (audioSource.isPlaying) { float currentTime = audioSource.time; // Display the words when their start times are reached if (currentLineIndex < lineTimestamps.Count && currentTime >= lineTimestamps\[currentLineIndex\]) { foreach (LyricWord word in lyricsLines\[currentLineIndex\]) { word.text.gameObject.SetActive(true); StartCoroutine(HighlightWord(word)); } currentLineIndex++; } // Hide the words when their end times are reached for (int i = 0; i < currentLineIndex; i++) { if (currentTime >= lineEndTimestamps\[i\]) { foreach (LyricWord word in lyricsLines\[i\]) { if (word.text.gameObject.activeSelf) { word.text.gameObject.SetActive(false); } } } } yield return null; } } private IEnumerator HighlightWord(LyricWord word) { yield return new WaitForSeconds(word.startTime - audioSource.time); word.text.color = highlightedTextColor; yield return new WaitForSeconds(word.endTime - word.startTime); word.text.color = normalTextColor; } }

1 / 1

To spread the words over the entire available screen space and move to the next line if there's no room left, you can update the `CreateLyricsLine` method to account for the screen width and create new lines accordingly. Here's how you can modify the method:

1.  Define a variable to hold the maximum width for a line:

csharp

```csharp
private float maxLineWidth = 800f;
```

You can adjust this value according to your needs or calculate it based on the screen width.

2.  Update the `CreateLyricsLine` method to create new lines when there's no room left:

csharp

```csharp
private List<LyricWord> CreateLyricsLine(string inputText, float startTime)
{
    List<LyricWord> words = new List<LyricWord>();
    MatchCollection wordMatches = Regex.Matches(inputText, @"\{\\k(\d+)\}([^{]+)");

    float currentTime = startTime;

    // Add a temporary TextMeshProUGUI object to measure the text width
    TextMeshProUGUI tempText = CreateTextObject("", Vector2.zero);
    float currentXPosition = 0;
    float currentYPosition = 0;

    foreach (Match wordMatch in wordMatches)
    {
        float wordDuration = float.Parse(wordMatch.Groups[1].Value) / 100f;
        string wordText = wordMatch.Groups[2].Value;

        // Measure the text width
        tempText.text = wordText;
        float wordWidth = tempText.preferredWidth;

        // Check if there's enough room left on the current line
        if (currentXPosition + wordWidth > maxLineWidth)
        {
            // Move to the next line
            currentXPosition = 0;
            currentYPosition -= tempText.preferredHeight + 10; // Add a small space between the lines
        }

        // Create the word object with the calculated anchor position
        LyricWord word = new LyricWord
        {
            text = CreateTextObject(wordText, new Vector2(currentXPosition, currentYPosition)),
            startTime = currentTime,
            endTime = currentTime + wordDuration
        };

        // Add the word to the list of words
        words.Add(word);

        // Update the current time and X position
        currentTime += wordDuration;
        currentXPosition += wordWidth;

        // Add a small space between the words
        currentXPosition += 10;
    }

    // Destroy the temporary TextMeshProUGUI object
    Destroy(tempText.gameObject);

    return words;
}
```

This modification calculates the remaining space on the current line, and if there's not enough room for the next word, it moves the word to the next line with a small space between the lines. This should prevent words from overlapping and spread them across the available screen space.

> 1 / 1
> 
> The words are still not using the left side of the screen, they are squished together on the right side of the screen starting from the centre over to the right Here is the current code for reference: using UnityEngine; using TMPro; using System.Collections; using System.Collections.Generic; using System.Text.RegularExpressions; public class LyricsSynchronizer : MonoBehaviour { public RectTransform lyricsParent; public AudioClip audioClip; public string lyricsFileName = "Never-Gonna-Poop-You-Up-Lyrics"; public Color normalTextColor = Color.black; public Color highlightedTextColor = Color.yellow; private AudioSource audioSource; private List<List<LyricWord>> lyricsLines = new List<List<LyricWord>>(); private List<float> lineEndTimestamps = new List<float>(); private float maxLineWidth = 800f; private class LyricWord { public TextMeshProUGUI text; public float startTime; public float endTime; } private void Start() { // Load lyrics from the text file LoadLyrics(); audioSource = gameObject.AddComponent<AudioSource>(); audioSource.clip = audioClip; audioSource.Play(); StartCoroutine(SyncLyrics()); } private List<float> lineTimestamps = new List<float>(); private void LoadLyrics() { TextAsset lyricsFile = Resources.Load<TextAsset>(lyricsFileName); string\[\] lines = lyricsFile.text.Split('\\n'); for (int i = 0; i < lines.Length; i++) { if (lines\[i\].StartsWith("Dialogue:")) { string\[\] parts = lines\[i\].Split(','); // Parse the start timestamp string\[\] startTimeParts = parts\[1\].Split(':'); float startHours = float.Parse(startTimeParts\[0\]); float startMinutes = float.Parse(startTimeParts\[1\]); float startSeconds = float.Parse(startTimeParts\[2\]); float startTimestamp = startHours \* 3600 + startMinutes \* 60 + startSeconds; // Parse the end timestamp string\[\] endTimeParts = parts\[2\].Split(':'); float endHours = float.Parse(endTimeParts\[0\]); float endMinutes = float.Parse(endTimeParts\[1\]); float endSeconds = float.Parse(endTimeParts\[2\]); float endTimestamp = endHours \* 3600 + endMinutes \* 60 + endSeconds; // Add the start and end timestamps to the lists lineTimestamps.Add(startTimestamp); lineEndTimestamps.Add(endTimestamp); // Get the lyrics line text string lyricsLineText = Regex.Match(lines\[i\], @"(?<=^\[^,\]\*(?:,\[^,\]\*){8},).\*$").Value.Trim(); // Check if the line has karaoke mode if (Regex.IsMatch(lyricsLineText, @"\\{\\\\k\\d+\\}")) { // Remove formatting tags (like "{\\k30}") from the text string plainText = Regex.Replace(lyricsLineText, @"\\{\[^}\]\*\\}", ""); // Create the lyric words List<LyricWord> words = CreateLyricsLine(lyricsLineText, startTimestamp); // Add the words to the list of lyrics lines lyricsLines.Add(words); } else { // If the line doesn't have karaoke mode, create a single LyricWord for the entire line LyricWord word = new LyricWord { text = CreateTextObject(lyricsLineText, Vector2.zero), startTime = startTimestamp, endTime = endTimestamp }; // Add the word to the list of lyrics lines lyricsLines.Add(new List<LyricWord> { word }); } } } } private List<LyricWord> CreateLyricsLine(string inputText, float startTime) { List<LyricWord> words = new List<LyricWord>(); MatchCollection wordMatches = Regex.Matches(inputText, @"\\{\\\\k(\\d+)\\}(\[^{\]+)"); float currentTime = startTime; // Add a temporary TextMeshProUGUI object to measure the text width TextMeshProUGUI tempText = CreateTextObject("", Vector2.zero); float currentXPosition = 0; float currentYPosition = 0; foreach (Match wordMatch in wordMatches) { float wordDuration = float.Parse(wordMatch.Groups\[1\].Value) / 100f; string wordText = wordMatch.Groups\[2\].Value; // Measure the text width tempText.text = wordText; float wordWidth = tempText.preferredWidth; // Check if there's enough room left on the current line if (currentXPosition + wordWidth > maxLineWidth) { // Move to the next line currentXPosition = 0; currentYPosition -= tempText.preferredHeight + 10; // Add a small space between the lines } // Create the word object with the calculated anchor position LyricWord word = new LyricWord { text = CreateTextObject(wordText, new Vector2(currentXPosition, currentYPosition)), startTime = currentTime, endTime = currentTime + wordDuration }; // Add the word to the list of words words.Add(word); // Update the current time and X position currentTime += wordDuration; currentXPosition += wordWidth; // Add a small space between the words currentXPosition += 10; } // Destroy the temporary TextMeshProUGUI object Destroy(tempText.gameObject); return words; } private TextMeshProUGUI CreateTextObject(string wordText, Vector2 anchorPosition) { GameObject textObj = new GameObject("Lyric Word"); textObj.transform.SetParent(lyricsParent, false); TextMeshProUGUI text = textObj.AddComponent<TextMeshProUGUI>(); // Set the text properties (font, size, color, etc.) here // Adjust the size of the RectTransform RectTransform rectTransform = text.GetComponent<RectTransform>(); rectTransform.sizeDelta = new Vector2(800, 100); // Increase the height text.color = normalTextColor; text.enableWordWrapping = true; text.alignment = TextAlignmentOptions.Midline; // Enable outline and set outline width and color text.fontMaterial.EnableKeyword("OUTLINE\_ON"); text.outlineWidth = 0.2f; text.outlineColor = Color.white; // Scale the text float scaleFactor = 2.0f; // Adjust this value to scale the text text.transform.localScale = new Vector3(scaleFactor, scaleFactor, scaleFactor); // Set font style to bold text.fontStyle = FontStyles.Bold; // Set the anchor position rectTransform.anchoredPosition = anchorPosition; text.text = wordText; return text; } private IEnumerator SyncLyrics() { int currentLineIndex = 0; // Initially, hide all the words foreach (List<LyricWord> words in lyricsLines) { foreach (LyricWord word in words) { word.text.gameObject.SetActive(false); } } while (audioSource.isPlaying) { float currentTime = audioSource.time; // Display the words when their start times are reached if (currentLineIndex < lineTimestamps.Count && currentTime >= lineTimestamps\[currentLineIndex\]) { foreach (LyricWord word in lyricsLines\[currentLineIndex\]) { word.text.gameObject.SetActive(true); StartCoroutine(HighlightWord(word)); } currentLineIndex++; } // Hide the words when their end times are reached for (int i = 0; i < currentLineIndex; i++) { if (currentTime >= lineEndTimestamps\[i\]) { foreach (LyricWord word in lyricsLines\[i\]) { if (word.text.gameObject.activeSelf) { word.text.gameObject.SetActive(false); } } } } yield return null; } } private IEnumerator HighlightWord(LyricWord word) { yield return new WaitForSeconds(word.startTime - audioSource.time); word.text.color = highlightedTextColor; yield return new WaitForSeconds(word.endTime - word.startTime); word.text.color = normalTextColor; } }

1 / 1

It looks like the lyrics are being centered due to the `text.alignment` property being set to `TextAlignmentOptions.Midline`. To make the lyrics aligned to the left, you can change the `text.alignment` property to `TextAlignmentOptions.Left`.

In the `CreateTextObject` function, change this line:

csharp

```csharp
text.alignment = TextAlignmentOptions.Midline;
```

to:

csharp

```csharp
text.alignment = TextAlignmentOptions.Left;
```

This should make the lyrics align to the left side of the screen.

> 1 / 1
> 
> Can we make the text.alignment left aligned only for karaoke lines?

1 / 1

Yes, you can adjust the `text.alignment` property based on whether the line has karaoke mode or not. First, you need to pass a flag to the `CreateTextObject` function to indicate whether it should create a karaoke line or not. Then, you can set the alignment depending on the flag.

Modify the `LoadLyrics` function, and pass `true` when calling `CreateLyricsLine` for karaoke lines and `false` otherwise:

csharp

```csharp
// For karaoke lines
List<LyricWord> words = CreateLyricsLine(lyricsLineText, startTimestamp, true);

// For non-karaoke lines
LyricWord word = new LyricWord
{
    text = CreateTextObject(lyricsLineText, Vector2.zero, false),
    startTime = startTimestamp,
    endTime = endTimestamp
};
```

Next, update the `CreateLyricsLine` function definition to include a `bool isKaraokeLine` parameter:

csharp

```csharp
private List<LyricWord> CreateLyricsLine(string inputText, float startTime, bool isKaraokeLine)
```

And pass this flag when calling `CreateTextObject`:

csharp

```csharp
text = CreateTextObject(wordText, new Vector2(currentXPosition, currentYPosition), isKaraokeLine)
```

Now, modify the `CreateTextObject` function definition to include the `bool isKaraokeLine` parameter:

csharp

```csharp
private TextMeshProUGUI CreateTextObject(string wordText, Vector2 anchorPosition, bool isKaraokeLine)
```

Finally, set the alignment in the `CreateTextObject` function depending on the `isKaraokeLine` flag:

csharp

```csharp
if (isKaraokeLine)
{
    text.alignment = TextAlignmentOptions.Left;
}
else
{
    text.alignment = TextAlignmentOptions.Midline;
}
```

With these changes, karaoke lines will be left-aligned, while non-karaoke lines will remain centered.

> 1 / 1
> 
> I'm getting this error: Assets\\scripts\\LyricsSynchronizer.cs(110,36): error CS7036: There is no argument given that corresponds to the required formal parameter 'isKaraokeLine' of 'LyricsSynchronizer.CreateTextObject(string, Vector2, bool)' Relating to: // Add a temporary TextMeshProUGUI object to measure the text width TextMeshProUGUI tempText = CreateTextObject("", Vector2.zero);

1 / 1

Apologies for the oversight. You need to pass the `isKaraokeLine` parameter when creating the temporary `TextMeshProUGUI` object. In this case, you can pass `false` since it's just for measuring text width.

Update the line creating the temporary `TextMeshProUGUI` object in the `CreateLyricsLine` function as follows:

csharp

```csharp
// Add a temporary TextMeshProUGUI object to measure the text width
TextMeshProUGUI tempText = CreateTextObject("", Vector2.zero, false);
```

With this change, the error should be resolved.

> 1 / 1
> 
> Okay, that works better, but the words are still not taking up the whole line and are still being drawn on top of each other. 800f should be enough space so I don't think the width is causing it Here is the current code: using UnityEngine; using TMPro; using System.Collections; using System.Collections.Generic; using System.Text.RegularExpressions; public class LyricsSynchronizer : MonoBehaviour { public RectTransform lyricsParent; public AudioClip audioClip; public string lyricsFileName = "Never-Gonna-Poop-You-Up-Lyrics"; public Color normalTextColor = Color.black; public Color highlightedTextColor = Color.yellow; private AudioSource audioSource; private List<List<LyricWord>> lyricsLines = new List<List<LyricWord>>(); private List<float> lineEndTimestamps = new List<float>(); private float maxLineWidth = 800f; private class LyricWord { public TextMeshProUGUI text; public float startTime; public float endTime; } private void Start() { // Load lyrics from the text file LoadLyrics(); audioSource = gameObject.AddComponent<AudioSource>(); audioSource.clip = audioClip; audioSource.Play(); StartCoroutine(SyncLyrics()); } private List<float> lineTimestamps = new List<float>(); private void LoadLyrics() { TextAsset lyricsFile = Resources.Load<TextAsset>(lyricsFileName); string\[\] lines = lyricsFile.text.Split('\\n'); for (int i = 0; i < lines.Length; i++) { if (lines\[i\].StartsWith("Dialogue:")) { string\[\] parts = lines\[i\].Split(','); // Parse the start timestamp string\[\] startTimeParts = parts\[1\].Split(':'); float startHours = float.Parse(startTimeParts\[0\]); float startMinutes = float.Parse(startTimeParts\[1\]); float startSeconds = float.Parse(startTimeParts\[2\]); float startTimestamp = startHours \* 3600 + startMinutes \* 60 + startSeconds; // Parse the end timestamp string\[\] endTimeParts = parts\[2\].Split(':'); float endHours = float.Parse(endTimeParts\[0\]); float endMinutes = float.Parse(endTimeParts\[1\]); float endSeconds = float.Parse(endTimeParts\[2\]); float endTimestamp = endHours \* 3600 + endMinutes \* 60 + endSeconds; // Add the start and end timestamps to the lists lineTimestamps.Add(startTimestamp); lineEndTimestamps.Add(endTimestamp); // Get the lyrics line text string lyricsLineText = Regex.Match(lines\[i\], @"(?<=^\[^,\]\*(?:,\[^,\]\*){8},).\*$").Value.Trim(); // Check if the line has karaoke mode if (Regex.IsMatch(lyricsLineText, @"\\{\\\\k\\d+\\}")) { // Remove formatting tags (like "{\\k30}") from the text string plainText = Regex.Replace(lyricsLineText, @"\\{\[^}\]\*\\}", ""); // For karaoke lines List<LyricWord> words = CreateLyricsLine(lyricsLineText, startTimestamp, true); // Add the words to the list of lyrics lines lyricsLines.Add(words); } else { // If the line doesn't have karaoke mode, create a single LyricWord for the entire line LyricWord word = new LyricWord { text = CreateTextObject(lyricsLineText, Vector2.zero, false), startTime = startTimestamp, endTime = endTimestamp }; // Add the word to the list of lyrics lines lyricsLines.Add(new List<LyricWord> { word }); } } } } private List<LyricWord> CreateLyricsLine(string inputText, float startTime, bool isKaraokeLine) { List<LyricWord> words = new List<LyricWord>(); MatchCollection wordMatches = Regex.Matches(inputText, @"\\{\\\\k(\\d+)\\}(\[^{\]+)"); float currentTime = startTime; // Add a temporary TextMeshProUGUI object to measure the text width TextMeshProUGUI tempText = CreateTextObject("", Vector2.zero, false); float currentXPosition = 0; float currentYPosition = 0; foreach (Match wordMatch in wordMatches) { float wordDuration = float.Parse(wordMatch.Groups\[1\].Value) / 100f; string wordText = wordMatch.Groups\[2\].Value; // Measure the text width tempText.text = wordText; float wordWidth = tempText.preferredWidth; // Check if there's enough room left on the current line if (currentXPosition + wordWidth > maxLineWidth) { // Move to the next line currentXPosition = 0; currentYPosition -= tempText.preferredHeight + 10; // Add a small space between the lines } // Create the word object with the calculated anchor position LyricWord word = new LyricWord { text = CreateTextObject(wordText, new Vector2(currentXPosition, currentYPosition), isKaraokeLine), startTime = currentTime, endTime = currentTime + wordDuration }; // Add the word to the list of words words.Add(word); // Update the current time and X position currentTime += wordDuration; currentXPosition += wordWidth; // Add a small space between the words currentXPosition += 10; } // Destroy the temporary TextMeshProUGUI object Destroy(tempText.gameObject); return words; } private TextMeshProUGUI CreateTextObject(string wordText, Vector2 anchorPosition, bool isKaraokeLine) { GameObject textObj = new GameObject("Lyric Word"); textObj.transform.SetParent(lyricsParent, false); TextMeshProUGUI text = textObj.AddComponent<TextMeshProUGUI>(); // Set the text properties (font, size, color, etc.) here // Adjust the size of the RectTransform RectTransform rectTransform = text.GetComponent<RectTransform>(); rectTransform.sizeDelta = new Vector2(800, 100); // Increase the height text.color = normalTextColor; text.enableWordWrapping = true; if (isKaraokeLine) { text.alignment = TextAlignmentOptions.Left; } else { text.alignment = TextAlignmentOptions.Midline; } // Enable outline and set outline width and color text.fontMaterial.EnableKeyword("OUTLINE\_ON"); text.outlineWidth = 0.2f; text.outlineColor = Color.white; // Scale the text float scaleFactor = 2.0f; // Adjust this value to scale the text text.transform.localScale = new Vector3(scaleFactor, scaleFactor, scaleFactor); // Set font style to bold text.fontStyle = FontStyles.Bold; // Set the anchor position rectTransform.anchoredPosition = anchorPosition; text.text = wordText; return text; } private IEnumerator SyncLyrics() { int currentLineIndex = 0; // Initially, hide all the words foreach (List<LyricWord> words in lyricsLines) { foreach (LyricWord word in words) { word.text.gameObject.SetActive(false); } } while (audioSource.isPlaying) { float currentTime = audioSource.time; // Display the words when their start times are reached if (currentLineIndex < lineTimestamps.Count && currentTime >= lineTimestamps\[currentLineIndex\]) { foreach (LyricWord word in lyricsLines\[currentLineIndex\]) { word.text.gameObject.SetActive(true); StartCoroutine(HighlightWord(word)); } currentLineIndex++; } // Hide the words when their end times are reached for (int i = 0; i < currentLineIndex; i++) { if (currentTime >= lineEndTimestamps\[i\]) { foreach (LyricWord word in lyricsLines\[i\]) { if (word.text.gameObject.activeSelf) { word.text.gameObject.SetActive(false); } } } } yield return null; } } private IEnumerator HighlightWord(LyricWord word) { yield return new WaitForSeconds(word.startTime - audioSource.time); word.text.color = highlightedTextColor; yield return new WaitForSeconds(word.endTime - word.startTime); word.text.color = normalTextColor; } }

1 / 1

I see the issue now. The `TextMeshProUGUI` component's `enableWordWrapping` property is set to `true` by default, causing the text to wrap if it exceeds the RectTransform width. Since we set the width to 800 in the `CreateTextObject` method, the text wraps within the 800 units. To fix this, you should disable word wrapping.

Modify the `CreateTextObject` method and set `enableWordWrapping` to `false`:

csharp

```csharp
private TextMeshProUGUI CreateTextObject(string wordText, Vector2 anchorPosition, bool isKaraokeLine)
{
    ...
    text.color = normalTextColor;
    text.enableWordWrapping = false; // Disable word wrapping
    ...
}
```

Now, the words should not wrap and instead be displayed in a single line.

> 1 / 1
> 
> again, we want to ensure this is still enabled if the line is not a karaoke line

1 / 1

You're right. We should only disable word wrapping for karaoke lines. Modify the `CreateTextObject` method to set `enableWordWrapping` based on the `isKaraokeLine` parameter:

csharp

```csharp
private TextMeshProUGUI CreateTextObject(string wordText, Vector2 anchorPosition, bool isKaraokeLine)
{
    ...
    text.color = normalTextColor;
    text.enableWordWrapping = !isKaraokeLine; // Disable word wrapping for karaoke lines only
    ...
}
```

Now, word wrapping will be disabled for karaoke lines and enabled for non-karaoke lines.

> 1 / 1
> 
> Nope that still hasn't fixed the issue. For Karaoke lines the words start on the left, and only extend to the middle of the screen and are overlapping each other. The horizontal positions of the words needs to be about twice as wide

1 / 1

It seems the issue might be related to scaling the text. When we scale the text, it doesn't affect the preferred width of the text. You should try calculating the word width after applying the scale factor. Modify the `CreateLyricsLine` method:

csharp

```csharp
private List<LyricWord> CreateLyricsLine(string inputText, float startTime, bool isKaraokeLine)
{
    ...
    float currentXPosition = 0;
    float currentYPosition = 0;

    // Add a temporary TextMeshProUGUI object to measure the text width
    TextMeshProUGUI tempText = CreateTextObject("", Vector2.zero, false);

    float scaleFactor = 2.0f; // Same scale factor as in CreateTextObject()

    foreach (Match wordMatch in wordMatches)
    {
        ...
        // Measure the text width
        tempText.text = wordText;
        float wordWidth = tempText.preferredWidth * scaleFactor; // Apply the scale factor
        ...
    }

    // Destroy the temporary TextMeshProUGUI object
    Destroy(tempText.gameObject);

    return words;
}
```

By multiplying the preferred width of the text by the scale factor, the words should be spaced properly and not overlap each other.

> 1 / 1
> 
> I get this error: Assets\\scripts\\LyricsSynchronizer.cs(115,25): error CS0128: A local variable or function named 'tempText' is already defined in this scope Can you verify I edited the code correctly? Here is the current code: using UnityEngine; using TMPro; using System.Collections; using System.Collections.Generic; using System.Text.RegularExpressions; public class LyricsSynchronizer : MonoBehaviour { public RectTransform lyricsParent; public AudioClip audioClip; public string lyricsFileName = "Never-Gonna-Poop-You-Up-Lyrics"; public Color normalTextColor = Color.black; public Color highlightedTextColor = Color.yellow; private AudioSource audioSource; private List<List<LyricWord>> lyricsLines = new List<List<LyricWord>>(); private List<float> lineEndTimestamps = new List<float>(); private float maxLineWidth = 800f; private class LyricWord { public TextMeshProUGUI text; public float startTime; public float endTime; } private void Start() { // Load lyrics from the text file LoadLyrics(); audioSource = gameObject.AddComponent<AudioSource>(); audioSource.clip = audioClip; audioSource.Play(); StartCoroutine(SyncLyrics()); } private List<float> lineTimestamps = new List<float>(); private void LoadLyrics() { TextAsset lyricsFile = Resources.Load<TextAsset>(lyricsFileName); string\[\] lines = lyricsFile.text.Split('\\n'); for (int i = 0; i < lines.Length; i++) { if (lines\[i\].StartsWith("Dialogue:")) { string\[\] parts = lines\[i\].Split(','); // Parse the start timestamp string\[\] startTimeParts = parts\[1\].Split(':'); float startHours = float.Parse(startTimeParts\[0\]); float startMinutes = float.Parse(startTimeParts\[1\]); float startSeconds = float.Parse(startTimeParts\[2\]); float startTimestamp = startHours \* 3600 + startMinutes \* 60 + startSeconds; // Parse the end timestamp string\[\] endTimeParts = parts\[2\].Split(':'); float endHours = float.Parse(endTimeParts\[0\]); float endMinutes = float.Parse(endTimeParts\[1\]); float endSeconds = float.Parse(endTimeParts\[2\]); float endTimestamp = endHours \* 3600 + endMinutes \* 60 + endSeconds; // Add the start and end timestamps to the lists lineTimestamps.Add(startTimestamp); lineEndTimestamps.Add(endTimestamp); // Get the lyrics line text string lyricsLineText = Regex.Match(lines\[i\], @"(?<=^\[^,\]\*(?:,\[^,\]\*){8},).\*$").Value.Trim(); // Check if the line has karaoke mode if (Regex.IsMatch(lyricsLineText, @"\\{\\\\k\\d+\\}")) { // Remove formatting tags (like "{\\k30}") from the text string plainText = Regex.Replace(lyricsLineText, @"\\{\[^}\]\*\\}", ""); // For karaoke lines List<LyricWord> words = CreateLyricsLine(lyricsLineText, startTimestamp, true); // Add the words to the list of lyrics lines lyricsLines.Add(words); } else { // If the line doesn't have karaoke mode, create a single LyricWord for the entire line LyricWord word = new LyricWord { text = CreateTextObject(lyricsLineText, Vector2.zero, false), startTime = startTimestamp, endTime = endTimestamp }; // Add the word to the list of lyrics lines lyricsLines.Add(new List<LyricWord> { word }); } } } } private List<LyricWord> CreateLyricsLine(string inputText, float startTime, bool isKaraokeLine) { List<LyricWord> words = new List<LyricWord>(); MatchCollection wordMatches = Regex.Matches(inputText, @"\\{\\\\k(\\d+)\\}(\[^{\]+)"); float currentTime = startTime; // Add a temporary TextMeshProUGUI object to measure the text width TextMeshProUGUI tempText = CreateTextObject("", Vector2.zero, false); float currentXPosition = 0; float currentYPosition = 0; // Add a temporary TextMeshProUGUI object to measure the text width TextMeshProUGUI tempText = CreateTextObject("", Vector2.zero, false); float scaleFactor = 2.0f; // Same scale factor as in CreateTextObject() foreach (Match wordMatch in wordMatches) { float wordDuration = float.Parse(wordMatch.Groups\[1\].Value) / 100f; string wordText = wordMatch.Groups\[2\].Value; // Measure the text width tempText.text = wordText; float wordWidth = tempText.preferredWidth \* scaleFactor; // Apply the scale factor // Check if there's enough room left on the current line if (currentXPosition + wordWidth > maxLineWidth) { // Move to the next line currentXPosition = 0; currentYPosition -= tempText.preferredHeight + 10; // Add a small space between the lines } // Create the word object with the calculated anchor position LyricWord word = new LyricWord { text = CreateTextObject(wordText, new Vector2(currentXPosition, currentYPosition), isKaraokeLine), startTime = currentTime, endTime = currentTime + wordDuration }; // Add the word to the list of words words.Add(word); // Update the current time and X position currentTime += wordDuration; currentXPosition += wordWidth; // Add a small space between the words currentXPosition += 10; } // Destroy the temporary TextMeshProUGUI object Destroy(tempText.gameObject); return words; } private TextMeshProUGUI CreateTextObject(string wordText, Vector2 anchorPosition, bool isKaraokeLine) { GameObject textObj = new GameObject("Lyric Word"); textObj.transform.SetParent(lyricsParent, false); TextMeshProUGUI text = textObj.AddComponent<TextMeshProUGUI>(); // Set the text properties (font, size, color, etc.) here // Adjust the size of the RectTransform RectTransform rectTransform = text.GetComponent<RectTransform>(); rectTransform.sizeDelta = new Vector2(800, 100); // Increase the height text.color = normalTextColor; text.enableWordWrapping = !isKaraokeLine; // Disable word wrapping for karaoke if (isKaraokeLine) { text.alignment = TextAlignmentOptions.Left; } else { text.alignment = TextAlignmentOptions.Midline; } // Enable outline and set outline width and color text.fontMaterial.EnableKeyword("OUTLINE\_ON"); text.outlineWidth = 0.2f; text.outlineColor = Color.white; // Scale the text float scaleFactor = 2.0f; // Adjust this value to scale the text text.transform.localScale = new Vector3(scaleFactor, scaleFactor, scaleFactor); // Set font style to bold text.fontStyle = FontStyles.Bold; // Set the anchor position rectTransform.anchoredPosition = anchorPosition; text.text = wordText; return text; } private IEnumerator SyncLyrics() { int currentLineIndex = 0; // Initially, hide all the words foreach (List<LyricWord> words in lyricsLines) { foreach (LyricWord word in words) { word.text.gameObject.SetActive(false); } } while (audioSource.isPlaying) { float currentTime = audioSource.time; // Display the words when their start times are reached if (currentLineIndex < lineTimestamps.Count && currentTime >= lineTimestamps\[currentLineIndex\]) { foreach (LyricWord word in lyricsLines\[currentLineIndex\]) { word.text.gameObject.SetActive(true); StartCoroutine(HighlightWord(word)); } currentLineIndex++; } // Hide the words when their end times are reached for (int i = 0; i < currentLineIndex; i++) { if (currentTime >= lineEndTimestamps\[i\]) { foreach (LyricWord word in lyricsLines\[i\]) { if (word.text.gameObject.activeSelf) { word.text.gameObject.SetActive(false); } } } } yield return null; } } private IEnumerator HighlightWord(LyricWord word) { yield return new WaitForSeconds(word.startTime - audioSource.time); word.text.color = highlightedTextColor; yield return new WaitForSeconds(word.endTime - word.startTime); word.text.color = normalTextColor; } }

1 / 1

Apologies for the confusion. It looks like there's a duplicate declaration of the `tempText` variable. Please remove one of them to fix the error. Here's the updated `CreateLyricsLine` method:

csharp

```csharp
private List<LyricWord> CreateLyricsLine(string inputText, float startTime, bool isKaraokeLine)
{
    List<LyricWord> words = new List<LyricWord>();
    MatchCollection wordMatches = Regex.Matches(inputText, @"\{\\k(\d+)\}([^{]+)");

    float currentTime = startTime;

    // Add a temporary TextMeshProUGUI object to measure the text width
    TextMeshProUGUI tempText = CreateTextObject("", Vector2.zero, false);
    float currentXPosition = 0;
    float currentYPosition = 0;

    float scaleFactor = 2.0f; // Same scale factor as in CreateTextObject()

    foreach (Match wordMatch in wordMatches)
    {
        float wordDuration = float.Parse(wordMatch.Groups[1].Value) / 100f;
        string wordText = wordMatch.Groups[2].Value;

        // Measure the text width
        tempText.text = wordText;
        float wordWidth = tempText.preferredWidth * scaleFactor; // Apply the scale factor

        // Check if there's enough room left on the current line
        if (currentXPosition + wordWidth > maxLineWidth)
        {
            // Move to the next line
            currentXPosition = 0;
            currentYPosition -= tempText.preferredHeight + 10; // Add a small space between the lines
        }

        // Create the word object with the calculated anchor position
        LyricWord word = new LyricWord
        {
            text = CreateTextObject(wordText, new Vector2(currentXPosition, currentYPosition), isKaraokeLine),
            startTime = currentTime,
            endTime = currentTime + wordDuration
        };

        // Add the word to the list of words
        words.Add(word);

        // Update the current time and X position
        currentTime += wordDuration;
        currentXPosition += wordWidth;

        // Add a small space between the words
        currentXPosition += 10;
    }

    // Destroy the temporary TextMeshProUGUI object
    Destroy(tempText.gameObject);

    return words;
}
```

I removed the second `tempText` declaration, and the rest of the code remains the same.

> 1 / 1
> 
> Okay that's much better but the positions of the karaoke words are still not wide enough. They are only taking half the screen width currently and are moving to the next line without needing to. Here is the current code for reference: using UnityEngine; using TMPro; using System.Collections; using System.Collections.Generic; using System.Text.RegularExpressions; public class LyricsSynchronizer : MonoBehaviour { public RectTransform lyricsParent; public AudioClip audioClip; public string lyricsFileName = "Never-Gonna-Poop-You-Up-Lyrics"; public Color normalTextColor = Color.black; public Color highlightedTextColor = Color.yellow; private AudioSource audioSource; private List<List<LyricWord>> lyricsLines = new List<List<LyricWord>>(); private List<float> lineEndTimestamps = new List<float>(); private float maxLineWidth = 800f; private class LyricWord { public TextMeshProUGUI text; public float startTime; public float endTime; } private void Start() { // Load lyrics from the text file LoadLyrics(); audioSource = gameObject.AddComponent<AudioSource>(); audioSource.clip = audioClip; audioSource.Play(); StartCoroutine(SyncLyrics()); } private List<float> lineTimestamps = new List<float>(); private void LoadLyrics() { TextAsset lyricsFile = Resources.Load<TextAsset>(lyricsFileName); string\[\] lines = lyricsFile.text.Split('\\n'); for (int i = 0; i < lines.Length; i++) { if (lines\[i\].StartsWith("Dialogue:")) { string\[\] parts = lines\[i\].Split(','); // Parse the start timestamp string\[\] startTimeParts = parts\[1\].Split(':'); float startHours = float.Parse(startTimeParts\[0\]); float startMinutes = float.Parse(startTimeParts\[1\]); float startSeconds = float.Parse(startTimeParts\[2\]); float startTimestamp = startHours \* 3600 + startMinutes \* 60 + startSeconds; // Parse the end timestamp string\[\] endTimeParts = parts\[2\].Split(':'); float endHours = float.Parse(endTimeParts\[0\]); float endMinutes = float.Parse(endTimeParts\[1\]); float endSeconds = float.Parse(endTimeParts\[2\]); float endTimestamp = endHours \* 3600 + endMinutes \* 60 + endSeconds; // Add the start and end timestamps to the lists lineTimestamps.Add(startTimestamp); lineEndTimestamps.Add(endTimestamp); // Get the lyrics line text string lyricsLineText = Regex.Match(lines\[i\], @"(?<=^\[^,\]\*(?:,\[^,\]\*){8},).\*$").Value.Trim(); // Check if the line has karaoke mode if (Regex.IsMatch(lyricsLineText, @"\\{\\\\k\\d+\\}")) { // Remove formatting tags (like "{\\k30}") from the text string plainText = Regex.Replace(lyricsLineText, @"\\{\[^}\]\*\\}", ""); // For karaoke lines List<LyricWord> words = CreateLyricsLine(lyricsLineText, startTimestamp, true); // Add the words to the list of lyrics lines lyricsLines.Add(words); } else { // If the line doesn't have karaoke mode, create a single LyricWord for the entire line LyricWord word = new LyricWord { text = CreateTextObject(lyricsLineText, Vector2.zero, false), startTime = startTimestamp, endTime = endTimestamp }; // Add the word to the list of lyrics lines lyricsLines.Add(new List<LyricWord> { word }); } } } } private List<LyricWord> CreateLyricsLine(string inputText, float startTime, bool isKaraokeLine) { List<LyricWord> words = new List<LyricWord>(); MatchCollection wordMatches = Regex.Matches(inputText, @"\\{\\\\k(\\d+)\\}(\[^{\]+)"); float currentTime = startTime; // Add a temporary TextMeshProUGUI object to measure the text width TextMeshProUGUI tempText = CreateTextObject("", Vector2.zero, false); float currentXPosition = 0; float currentYPosition = 0; float scaleFactor = 2.0f; // Same scale factor as in CreateTextObject() foreach (Match wordMatch in wordMatches) { float wordDuration = float.Parse(wordMatch.Groups\[1\].Value) / 100f; string wordText = wordMatch.Groups\[2\].Value; // Measure the text width tempText.text = wordText; float wordWidth = tempText.preferredWidth \* scaleFactor; // Apply the scale factor // Check if there's enough room left on the current line if (currentXPosition + wordWidth > maxLineWidth) { // Move to the next line currentXPosition = 0; currentYPosition -= tempText.preferredHeight + 10; // Add a small space between the lines } // Create the word object with the calculated anchor position LyricWord word = new LyricWord { text = CreateTextObject(wordText, new Vector2(currentXPosition, currentYPosition), isKaraokeLine), startTime = currentTime, endTime = currentTime + wordDuration }; // Add the word to the list of words words.Add(word); // Update the current time and X position currentTime += wordDuration; currentXPosition += wordWidth; // Add a small space between the words currentXPosition += 10; } // Destroy the temporary TextMeshProUGUI object Destroy(tempText.gameObject); return words; } private TextMeshProUGUI CreateTextObject(string wordText, Vector2 anchorPosition, bool isKaraokeLine) { GameObject textObj = new GameObject("Lyric Word"); textObj.transform.SetParent(lyricsParent, false); TextMeshProUGUI text = textObj.AddComponent<TextMeshProUGUI>(); // Set the text properties (font, size, color, etc.) here // Adjust the size of the RectTransform RectTransform rectTransform = text.GetComponent<RectTransform>(); rectTransform.sizeDelta = new Vector2(800, 100); // Increase the height text.color = normalTextColor; text.enableWordWrapping = !isKaraokeLine; // Disable word wrapping for karaoke if (isKaraokeLine) { text.alignment = TextAlignmentOptions.Left; } else { text.alignment = TextAlignmentOptions.Midline; } // Enable outline and set outline width and color text.fontMaterial.EnableKeyword("OUTLINE\_ON"); text.outlineWidth = 0.2f; text.outlineColor = Color.white; // Scale the text float scaleFactor = 2.0f; // Adjust this value to scale the text text.transform.localScale = new Vector3(scaleFactor, scaleFactor, scaleFactor); // Set font style to bold text.fontStyle = FontStyles.Bold; // Set the anchor position rectTransform.anchoredPosition = anchorPosition; text.text = wordText; return text; } private IEnumerator SyncLyrics() { int currentLineIndex = 0; // Initially, hide all the words foreach (List<LyricWord> words in lyricsLines) { foreach (LyricWord word in words) { word.text.gameObject.SetActive(false); } } while (audioSource.isPlaying) { float currentTime = audioSource.time; // Display the words when their start times are reached if (currentLineIndex < lineTimestamps.Count && currentTime >= lineTimestamps\[currentLineIndex\]) { foreach (LyricWord word in lyricsLines\[currentLineIndex\]) { word.text.gameObject.SetActive(true); StartCoroutine(HighlightWord(word)); } currentLineIndex++; } // Hide the words when their end times are reached for (int i = 0; i < currentLineIndex; i++) { if (currentTime >= lineEndTimestamps\[i\]) { foreach (LyricWord word in lyricsLines\[i\]) { if (word.text.gameObject.activeSelf) { word.text.gameObject.SetActive(false); } } } } yield return null; } } private IEnumerator HighlightWord(LyricWord word) { yield return new WaitForSeconds(word.startTime - audioSource.time); word.text.color = highlightedTextColor; yield return new WaitForSeconds(word.endTime - word.startTime); word.text.color = normalTextColor; } }

1 / 1

It looks like the problem is related to the width of the RectTransform of the text objects. The width of the RectTransform is currently set to 800, which is limiting the width of the text. To fix this issue, you can try setting the width of the RectTransform to a larger value, like the width of the screen.

To do that, replace the following line in the `CreateTextObject()` method:

csharp

```csharp
rectTransform.sizeDelta = new Vector2(800, 100); // Increase the height
```

with:

csharp

```csharp
rectTransform.sizeDelta = new Vector2(Screen.width, 100); // Set the width to the screen width
```

This should allow the text to take up the full width of the screen.

> 1 / 1
> 
> Thanks for the suggestion, but this is only occurring with karaoke lines

1 / 1

I apologize for the confusion. The issue seems to be related to the fact that karaoke lines are being split into separate words, and each word has its own RectTransform with a width of 800. To fix this, we can calculate the total width of the karaoke line and set the width of the RectTransform for each word accordingly.

To implement this, add the following method to the `LyricsSynchronizer` class:

csharp

```csharp
private float CalculateLineWidth(List<LyricWord> words, float scaleFactor)
{
    float totalWidth = 0;
    foreach (LyricWord word in words)
    {
        totalWidth += word.text.preferredWidth * scaleFactor;
    }
    return totalWidth;
}
```

Then, modify the `CreateLyricsLine()` method as follows:

1.  Calculate the total width of the line after creating the `words` list.
2.  Calculate the left padding for each word based on the total width and the `maxLineWidth`.
3.  Update the anchor position for each word with the new left padding.

csharp

```csharp
private List<LyricWord> CreateLyricsLine(string inputText, float startTime, bool isKaraokeLine)
{
    // ... (existing code)

    // Calculate the total width of the line
    float lineWidth = CalculateLineWidth(words, scaleFactor);

    // Calculate the left padding for each word
    float leftPadding = (maxLineWidth - lineWidth) / 2;

    // Update the anchor position for each word with the new left padding
    foreach (LyricWord word in words)
    {
        Vector2 anchorPosition = word.text.rectTransform.anchoredPosition;
        anchorPosition.x += leftPadding;
        word.text.rectTransform.anchoredPosition = anchorPosition;
    }

    return words;
}
```

This should adjust the width of the karaoke lines to take up the full width of the screen.

> 1 / 1
> 
> okay, now the karaoke lines are way over to the left, mostly off screen

1 / 1

Apologies for the issue. It seems the previous solution didn't work as intended. Let's try another approach to solve the issue. Instead of adjusting the anchor position for each word, we can adjust the `maxLineWidth` to allow the karaoke lines to span the entire width of the screen.

First, in the `LyricsSynchronizer` class, add a new public float variable to represent the karaoke line width:

csharp

```csharp
public float karaokeLineWidth = 1600f;
```

Then, modify the `CreateLyricsLine()` method as follows:

1.  Add a new argument `float lineWidth` to the method signature.
2.  Replace the `maxLineWidth` variable with the `lineWidth` argument.

csharp

```csharp
private List<LyricWord> CreateLyricsLine(string inputText, float startTime, bool isKaraokeLine, float lineWidth)
{
    // ... (existing code)

    // Check if there's enough room left on the current line
    if (currentXPosition + wordWidth > lineWidth)
    {
        // Move to the next line
        currentXPosition = 0;
        currentYPosition -= tempText.preferredHeight + 10; // Add a small space between the lines
    }

    // ... (rest of the code)
}
```

Now, update the calls to `CreateLyricsLine()` in the `LoadLyrics()` method:

For karaoke lines, pass `karaokeLineWidth` as the last argument:

csharp

```csharp
List<LyricWord> words = CreateLyricsLine(lyricsLineText, startTimestamp, true, karaokeLineWidth);
```

For non-karaoke lines, pass `maxLineWidth` as the last argument:

csharp

```csharp
LyricWord word = new LyricWord
{
    text = CreateTextObject(lyricsLineText, Vector2.zero, false),
    startTime = startTimestamp,
    endTime = endTimestamp
};
```

This should adjust the karaoke lines to span the entire width of the screen. You can also tweak the value of `karaokeLineWidth` in the Unity editor to get the desired width for karaoke lines.

> 1 / 1
> 
> We already have maxLineWidth defined, I just changed that to private float maxLineWidth = Screen.width; but it had no effect Should I still make the edit you suggested to add karaokeLineWidth? See the current code for reference: using UnityEngine; using TMPro; using System.Collections; using System.Collections.Generic; using System.Text.RegularExpressions; public class LyricsSynchronizer : MonoBehaviour { public RectTransform lyricsParent; public AudioClip audioClip; public string lyricsFileName = "Never-Gonna-Poop-You-Up-Lyrics"; public Color normalTextColor = Color.black; public Color highlightedTextColor = Color.yellow; private AudioSource audioSource; private List<List<LyricWord>> lyricsLines = new List<List<LyricWord>>(); private List<float> lineEndTimestamps = new List<float>(); private float maxLineWidth = Screen.width; private class LyricWord { public TextMeshProUGUI text; public float startTime; public float endTime; } private void Start() { // Load lyrics from the text file LoadLyrics(); audioSource = gameObject.AddComponent<AudioSource>(); audioSource.clip = audioClip; audioSource.Play(); StartCoroutine(SyncLyrics()); } private List<float> lineTimestamps = new List<float>(); private void LoadLyrics() { TextAsset lyricsFile = Resources.Load<TextAsset>(lyricsFileName); string\[\] lines = lyricsFile.text.Split('\\n'); for (int i = 0; i < lines.Length; i++) { if (lines\[i\].StartsWith("Dialogue:")) { string\[\] parts = lines\[i\].Split(','); // Parse the start timestamp string\[\] startTimeParts = parts\[1\].Split(':'); float startHours = float.Parse(startTimeParts\[0\]); float startMinutes = float.Parse(startTimeParts\[1\]); float startSeconds = float.Parse(startTimeParts\[2\]); float startTimestamp = startHours \* 3600 + startMinutes \* 60 + startSeconds; // Parse the end timestamp string\[\] endTimeParts = parts\[2\].Split(':'); float endHours = float.Parse(endTimeParts\[0\]); float endMinutes = float.Parse(endTimeParts\[1\]); float endSeconds = float.Parse(endTimeParts\[2\]); float endTimestamp = endHours \* 3600 + endMinutes \* 60 + endSeconds; // Add the start and end timestamps to the lists lineTimestamps.Add(startTimestamp); lineEndTimestamps.Add(endTimestamp); // Get the lyrics line text string lyricsLineText = Regex.Match(lines\[i\], @"(?<=^\[^,\]\*(?:,\[^,\]\*){8},).\*$").Value.Trim(); // Check if the line has karaoke mode if (Regex.IsMatch(lyricsLineText, @"\\{\\\\k\\d+\\}")) { // Remove formatting tags (like "{\\k30}") from the text string plainText = Regex.Replace(lyricsLineText, @"\\{\[^}\]\*\\}", ""); // For karaoke lines List<LyricWord> words = CreateLyricsLine(lyricsLineText, startTimestamp, true); // Add the words to the list of lyrics lines lyricsLines.Add(words); } else { // If the line doesn't have karaoke mode, create a single LyricWord for the entire line LyricWord word = new LyricWord { text = CreateTextObject(lyricsLineText, Vector2.zero, false), startTime = startTimestamp, endTime = endTimestamp }; // Add the word to the list of lyrics lines lyricsLines.Add(new List<LyricWord> { word }); } } } } private List<LyricWord> CreateLyricsLine(string inputText, float startTime, bool isKaraokeLine) { List<LyricWord> words = new List<LyricWord>(); MatchCollection wordMatches = Regex.Matches(inputText, @"\\{\\\\k(\\d+)\\}(\[^{\]+)"); float currentTime = startTime; // Add a temporary TextMeshProUGUI object to measure the text width TextMeshProUGUI tempText = CreateTextObject("", Vector2.zero, false); float currentXPosition = 0; float currentYPosition = 0; float scaleFactor = 2.0f; // Same scale factor as in CreateTextObject() foreach (Match wordMatch in wordMatches) { float wordDuration = float.Parse(wordMatch.Groups\[1\].Value) / 100f; string wordText = wordMatch.Groups\[2\].Value; // Measure the text width tempText.text = wordText; float wordWidth = tempText.preferredWidth \* scaleFactor; // Apply the scale factor // Check if there's enough room left on the current line if (currentXPosition + wordWidth > maxLineWidth) { // Move to the next line currentXPosition = 0; currentYPosition -= tempText.preferredHeight + 10; // Add a small space between the lines } // Create the word object with the calculated anchor position LyricWord word = new LyricWord { text = CreateTextObject(wordText, new Vector2(currentXPosition, currentYPosition), isKaraokeLine), startTime = currentTime, endTime = currentTime + wordDuration }; // Add the word to the list of words words.Add(word); // Update the current time and X position currentTime += wordDuration; currentXPosition += wordWidth; // Add a small space between the words currentXPosition += 10; } // Destroy the temporary TextMeshProUGUI object Destroy(tempText.gameObject); // Calculate the total width of the line float lineWidth = CalculateLineWidth(words, scaleFactor); // Calculate the left padding for each word float leftPadding = (maxLineWidth - lineWidth) / 2; // Update the anchor position for each word with the new left padding foreach (LyricWord word in words) { Vector2 anchorPosition = word.text.rectTransform.anchoredPosition; anchorPosition.x += leftPadding; word.text.rectTransform.anchoredPosition = anchorPosition; } return words; } private float CalculateLineWidth(List<LyricWord> words, float scaleFactor) { float totalWidth = 0; foreach (LyricWord word in words) { totalWidth += word.text.preferredWidth \* scaleFactor; } return totalWidth; } private TextMeshProUGUI CreateTextObject(string wordText, Vector2 anchorPosition, bool isKaraokeLine) { GameObject textObj = new GameObject("Lyric Word"); textObj.transform.SetParent(lyricsParent, false); TextMeshProUGUI text = textObj.AddComponent<TextMeshProUGUI>(); // Set the text properties (font, size, color, etc.) here // Adjust the size of the RectTransform RectTransform rectTransform = text.GetComponent<RectTransform>(); rectTransform.sizeDelta = new Vector2(Screen.width, 100); // Set the width to the screen width text.color = normalTextColor; text.enableWordWrapping = !isKaraokeLine; // Disable word wrapping for karaoke if (isKaraokeLine) { text.alignment = TextAlignmentOptions.Left; } else { text.alignment = TextAlignmentOptions.Midline; } // Enable outline and set outline width and color text.fontMaterial.EnableKeyword("OUTLINE\_ON"); text.outlineWidth = 0.2f; text.outlineColor = Color.white; // Scale the text float scaleFactor = 2.0f; // Adjust this value to scale the text text.transform.localScale = new Vector3(scaleFactor, scaleFactor, scaleFactor); // Set font style to bold text.fontStyle = FontStyles.Bold; // Set the anchor position rectTransform.anchoredPosition = anchorPosition; text.text = wordText; return text; } private IEnumerator SyncLyrics() { int currentLineIndex = 0; // Initially, hide all the words foreach (List<LyricWord> words in lyricsLines) { foreach (LyricWord word in words) { word.text.gameObject.SetActive(false); } } while (audioSource.isPlaying) { float currentTime = audioSource.time; // Display the words when their start times are reached if (currentLineIndex < lineTimestamps.Count && currentTime >= lineTimestamps\[currentLineIndex\]) { foreach (LyricWord word in lyricsLines\[currentLineIndex\]) { word.text.gameObject.SetActive(true); StartCoroutine(HighlightWord(word)); } currentLineIndex++; } // Hide the words when their end times are reached for (int i = 0; i < currentLineIndex; i++) { if (currentTime >= lineEndTimestamps\[i\]) { foreach (LyricWord word in lyricsLines\[i\]) { if (word.text.gameObject.activeSelf) { word.text.gameObject.SetActive(false); } } } } yield return null; } } private IEnumerator HighlightWord(LyricWord word) { yield return new WaitForSeconds(word.startTime - audioSource.time); word.text.color = highlightedTextColor; yield return new WaitForSeconds(word.endTime - word.startTime); word.text.color = normalTextColor; } }

1 / 1

I apologize for the confusion. Since you have already set the `maxLineWidth` to `Screen.width`, it should span the entire screen width. In that case, you might not need to add the `karaokeLineWidth` variable.

However, the issue may be that `Screen.width` is being assigned to `maxLineWidth` before the screen dimensions are properly initialized. You can move the assignment of `Screen.width` to `maxLineWidth` to the `Start()` method to ensure that it's assigned after the screen dimensions are initialized.

Here's how you can modify the `LyricsSynchronizer` class:

1.  Change the `maxLineWidth` initialization to just a declaration:

csharp

```csharp
private float maxLineWidth;
```

2.  Add the assignment of `Screen.width` to `maxLineWidth` in the `Start()` method:

csharp

```csharp
private void Start()
{
    maxLineWidth = Screen.width;

    // Load lyrics from the text file
    LoadLyrics();

    audioSource = gameObject.AddComponent<AudioSource>();
    audioSource.clip = audioClip;
    audioSource.Play();

    StartCoroutine(SyncLyrics());
}
```

This should ensure that `maxLineWidth` is set to the correct screen width when the script starts running.

> 1 / 1
> 
> I see the same issue, I don't think this is to do with the screen width. The line is rendering fine with a correct looking width, but the position of the entire karaoke line is too far to the left. It looks like the midpoint of the karaoke line is on the left edge of the screen. I want the karaoke line to be centred in the middle of the screen. Here is the current code for reference: using UnityEngine; using TMPro; using System.Collections; using System.Collections.Generic; using System.Text.RegularExpressions; public class LyricsSynchronizer : MonoBehaviour { public RectTransform lyricsParent; public AudioClip audioClip; public string lyricsFileName = "Never-Gonna-Poop-You-Up-Lyrics"; public Color normalTextColor = Color.black; public Color highlightedTextColor = Color.yellow; private AudioSource audioSource; private List<List<LyricWord>> lyricsLines = new List<List<LyricWord>>(); private List<float> lineEndTimestamps = new List<float>(); private float maxLineWidth; private class LyricWord { public TextMeshProUGUI text; public float startTime; public float endTime; } private void Start() { maxLineWidth = Screen.width; // Load lyrics from the text file LoadLyrics(); audioSource = gameObject.AddComponent<AudioSource>(); audioSource.clip = audioClip; audioSource.Play(); StartCoroutine(SyncLyrics()); } private List<float> lineTimestamps = new List<float>(); private void LoadLyrics() { TextAsset lyricsFile = Resources.Load<TextAsset>(lyricsFileName); string\[\] lines = lyricsFile.text.Split('\\n'); for (int i = 0; i < lines.Length; i++) { if (lines\[i\].StartsWith("Dialogue:")) { string\[\] parts = lines\[i\].Split(','); // Parse the start timestamp string\[\] startTimeParts = parts\[1\].Split(':'); float startHours = float.Parse(startTimeParts\[0\]); float startMinutes = float.Parse(startTimeParts\[1\]); float startSeconds = float.Parse(startTimeParts\[2\]); float startTimestamp = startHours \* 3600 + startMinutes \* 60 + startSeconds; // Parse the end timestamp string\[\] endTimeParts = parts\[2\].Split(':'); float endHours = float.Parse(endTimeParts\[0\]); float endMinutes = float.Parse(endTimeParts\[1\]); float endSeconds = float.Parse(endTimeParts\[2\]); float endTimestamp = endHours \* 3600 + endMinutes \* 60 + endSeconds; // Add the start and end timestamps to the lists lineTimestamps.Add(startTimestamp); lineEndTimestamps.Add(endTimestamp); // Get the lyrics line text string lyricsLineText = Regex.Match(lines\[i\], @"(?<=^\[^,\]\*(?:,\[^,\]\*){8},).\*$").Value.Trim(); // Check if the line has karaoke mode if (Regex.IsMatch(lyricsLineText, @"\\{\\\\k\\d+\\}")) { // Remove formatting tags (like "{\\k30}") from the text string plainText = Regex.Replace(lyricsLineText, @"\\{\[^}\]\*\\}", ""); // For karaoke lines List<LyricWord> words = CreateLyricsLine(lyricsLineText, startTimestamp, true); // Add the words to the list of lyrics lines lyricsLines.Add(words); } else { // If the line doesn't have karaoke mode, create a single LyricWord for the entire line LyricWord word = new LyricWord { text = CreateTextObject(lyricsLineText, Vector2.zero, false), startTime = startTimestamp, endTime = endTimestamp }; // Add the word to the list of lyrics lines lyricsLines.Add(new List<LyricWord> { word }); } } } } private List<LyricWord> CreateLyricsLine(string inputText, float startTime, bool isKaraokeLine) { List<LyricWord> words = new List<LyricWord>(); MatchCollection wordMatches = Regex.Matches(inputText, @"\\{\\\\k(\\d+)\\}(\[^{\]+)"); float currentTime = startTime; // Add a temporary TextMeshProUGUI object to measure the text width TextMeshProUGUI tempText = CreateTextObject("", Vector2.zero, false); float currentXPosition = 0; float currentYPosition = 0; float scaleFactor = 2.0f; // Same scale factor as in CreateTextObject() foreach (Match wordMatch in wordMatches) { float wordDuration = float.Parse(wordMatch.Groups\[1\].Value) / 100f; string wordText = wordMatch.Groups\[2\].Value; // Measure the text width tempText.text = wordText; float wordWidth = tempText.preferredWidth \* scaleFactor; // Apply the scale factor // Check if there's enough room left on the current line if (currentXPosition + wordWidth > maxLineWidth) { // Move to the next line currentXPosition = 0; currentYPosition -= tempText.preferredHeight + 10; // Add a small space between the lines } // Create the word object with the calculated anchor position LyricWord word = new LyricWord { text = CreateTextObject(wordText, new Vector2(currentXPosition, currentYPosition), isKaraokeLine), startTime = currentTime, endTime = currentTime + wordDuration }; // Add the word to the list of words words.Add(word); // Update the current time and X position currentTime += wordDuration; currentXPosition += wordWidth; // Add a small space between the words currentXPosition += 10; } // Destroy the temporary TextMeshProUGUI object Destroy(tempText.gameObject); // Calculate the total width of the line float lineWidth = CalculateLineWidth(words, scaleFactor); // Calculate the left padding for each word float leftPadding = (maxLineWidth - lineWidth) / 2; // Update the anchor position for each word with the new left padding foreach (LyricWord word in words) { Vector2 anchorPosition = word.text.rectTransform.anchoredPosition; anchorPosition.x += leftPadding; word.text.rectTransform.anchoredPosition = anchorPosition; } return words; } private float CalculateLineWidth(List<LyricWord> words, float scaleFactor) { float totalWidth = 0; foreach (LyricWord word in words) { totalWidth += word.text.preferredWidth \* scaleFactor; } return totalWidth; } private TextMeshProUGUI CreateTextObject(string wordText, Vector2 anchorPosition, bool isKaraokeLine) { GameObject textObj = new GameObject("Lyric Word"); textObj.transform.SetParent(lyricsParent, false); TextMeshProUGUI text = textObj.AddComponent<TextMeshProUGUI>(); // Set the text properties (font, size, color, etc.) here // Adjust the size of the RectTransform RectTransform rectTransform = text.GetComponent<RectTransform>(); rectTransform.sizeDelta = new Vector2(Screen.width, 100); // Set the width to the screen width text.color = normalTextColor; text.enableWordWrapping = !isKaraokeLine; // Disable word wrapping for karaoke if (isKaraokeLine) { text.alignment = TextAlignmentOptions.Left; } else { text.alignment = TextAlignmentOptions.Midline; } // Enable outline and set outline width and color text.fontMaterial.EnableKeyword("OUTLINE\_ON"); text.outlineWidth = 0.2f; text.outlineColor = Color.white; // Scale the text float scaleFactor = 2.0f; // Adjust this value to scale the text text.transform.localScale = new Vector3(scaleFactor, scaleFactor, scaleFactor); // Set font style to bold text.fontStyle = FontStyles.Bold; // Set the anchor position rectTransform.anchoredPosition = anchorPosition; text.text = wordText; return text; } private IEnumerator SyncLyrics() { int currentLineIndex = 0; // Initially, hide all the words foreach (List<LyricWord> words in lyricsLines) { foreach (LyricWord word in words) { word.text.gameObject.SetActive(false); } } while (audioSource.isPlaying) { float currentTime = audioSource.time; // Display the words when their start times are reached if (currentLineIndex < lineTimestamps.Count && currentTime >= lineTimestamps\[currentLineIndex\]) { foreach (LyricWord word in lyricsLines\[currentLineIndex\]) { word.text.gameObject.SetActive(true); StartCoroutine(HighlightWord(word)); } currentLineIndex++; } // Hide the words when their end times are reached for (int i = 0; i < currentLineIndex; i++) { if (currentTime >= lineEndTimestamps\[i\]) { foreach (LyricWord word in lyricsLines\[i\]) { if (word.text.gameObject.activeSelf) { word.text.gameObject.SetActive(false); } } } } yield return null; } } private IEnumerator HighlightWord(LyricWord word) { yield return new WaitForSeconds(word.startTime - audioSource.time); word.text.color = highlightedTextColor; yield return new WaitForSeconds(word.endTime - word.startTime); word.text.color = normalTextColor; } }

1 / 1

The issue seems to be that the anchor point for the RectTransform is set to the left edge of the screen. You should change the anchor point to the center of the screen. Modify the `CreateTextObject` method by adding the following line of code after creating the RectTransform:

csharp

```csharp
rectTransform.anchorMin = rectTransform.anchorMax = new Vector2(0.5f, 1);
```

This sets both the minimum and maximum anchor points to the center of the screen horizontally and the top vertically. Also, remove the `rectTransform.sizeDelta = new Vector2(Screen.width, 100);` line since it's no longer necessary.

Here's the modified `CreateTextObject` method:

csharp

```csharp
private TextMeshProUGUI CreateTextObject(string wordText, Vector2 anchorPosition, bool isKaraokeLine)
{
    GameObject textObj = new GameObject("Lyric Word");
    textObj.transform.SetParent(lyricsParent, false);
    TextMeshProUGUI text = textObj.AddComponent<TextMeshProUGUI>();

    // Adjust the size of the RectTransform
    RectTransform rectTransform = text.GetComponent<RectTransform>();
    rectTransform.anchorMin = rectTransform.anchorMax = new Vector2(0.5f, 1); // Set the anchor point to the center horizontally and the top vertically

    // Set the text properties (font, size, color, etc.) here
    // ...

    // Set the anchor position
    rectTransform.anchoredPosition = anchorPosition;

    text.text = wordText;

    return text;
}
```

With these changes, the karaoke line should now be centered in the middle of the screen.

> 1 / 1
> 
> Unfortunately that didn't work, the karaoke line is still centred on the left side of the screen. Did I edit the method correctly? private TextMeshProUGUI CreateTextObject(string wordText, Vector2 anchorPosition, bool isKaraokeLine) { GameObject textObj = new GameObject("Lyric Word"); textObj.transform.SetParent(lyricsParent, false); TextMeshProUGUI text = textObj.AddComponent<TextMeshProUGUI>(); // Set the text properties (font, size, color, etc.) here // Adjust the size of the RectTransform RectTransform rectTransform = text.GetComponent<RectTransform>(); rectTransform.anchorMin = rectTransform.anchorMax = new Vector2(0.5f, 1); rectTransform.sizeDelta = new Vector2(Screen.width, 100); // Set the width to the screen width text.color = normalTextColor; text.enableWordWrapping = !isKaraokeLine; // Disable word wrapping for karaoke if (isKaraokeLine) { text.alignment = TextAlignmentOptions.Left; } else { text.alignment = TextAlignmentOptions.Midline; } // Enable outline and set outline width and color text.fontMaterial.EnableKeyword("OUTLINE\_ON"); text.outlineWidth = 0.2f; text.outlineColor = Color.white; // Scale the text float scaleFactor = 2.0f; // Adjust this value to scale the text text.transform.localScale = new Vector3(scaleFactor, scaleFactor, scaleFactor); // Set font style to bold text.fontStyle = FontStyles.Bold; // Set the anchor position rectTransform.anchoredPosition = anchorPosition; text.text = wordText; return text; }

1 / 1

I apologize for the confusion. I realize my previous suggestion was not accurate. Let's try another approach.

Instead of modifying the `CreateTextObject` method, you can try to reposition the `lyricsParent` itself to align its center with the screen's center. Add the following lines of code to the `Start` method, right after initializing `maxLineWidth`:

csharp

```csharp
lyricsParent.anchorMin = lyricsParent.anchorMax = new Vector2(0.5f, 1);
lyricsParent.pivot = new Vector2(0.5f, 1);
lyricsParent.anchoredPosition = Vector2.zero;
```

This should set the anchor points, pivot, and position of the `lyricsParent` RectTransform to the center of the screen horizontally and the top vertically. Remove the `rectTransform.sizeDelta = new Vector2(Screen.width, 100);` line from the `CreateTextObject` method since it's not needed.

Here's the modified `Start` method:

csharp

```csharp
private void Start()
{
    maxLineWidth = Screen.width;

    lyricsParent.anchorMin = lyricsParent.anchorMax = new Vector2(0.5f, 1);
    lyricsParent.pivot = new Vector2(0.5f, 1);
    lyricsParent.anchoredPosition = Vector2.zero;

    // Load lyrics from the text file
    LoadLyrics();

    audioSource = gameObject.AddComponent<AudioSource>();
    audioSource.clip = audioClip;
    audioSource.Play();

    StartCoroutine(SyncLyrics());
}
```

With these changes, the karaoke line should now be centered in the middle of the screen.

> 1 / 1
> 
> okay, that's made a difference, but now the lines are drawn with the top centre of the screen being the centre of the line. I want the centre of the line to be the centre of the screen horizontally and vertically

1 / 1

I understand, you want the karaoke line to be centered both horizontally and vertically on the screen. You can modify the `lyricsParent` RectTransform's pivot and anchored position in the `Start` method to achieve this.

Update the `Start` method with the following changes:

csharp

```csharp
private void Start()
{
    maxLineWidth = Screen.width;

    lyricsParent.anchorMin = lyricsParent.anchorMax = new Vector2(0.5f, 0.5f);
    lyricsParent.pivot = new Vector2(0.5f, 0.5f);
    lyricsParent.anchoredPosition = Vector2.zero;

    // Load lyrics from the text file
    LoadLyrics();

    audioSource = gameObject.AddComponent<AudioSource>();
    audioSource.clip = audioClip;
    audioSource.Play();

    StartCoroutine(SyncLyrics());
}
```

This will set the anchor points, pivot, and position of the `lyricsParent` RectTransform to the center of the screen both horizontally and vertically. The karaoke line should now be centered in the middle of the screen horizontally and vertically.

> 1 / 1
> 
> Okay that's pretty good, but the non-karaoke lines are not taking up the screen width now. Can we get those to also use the same width as the karaoke lines? Code for reference: using UnityEngine; using TMPro; using System.Collections; using System.Collections.Generic; using System.Text.RegularExpressions; public class LyricsSynchronizer : MonoBehaviour { public RectTransform lyricsParent; public AudioClip audioClip; public string lyricsFileName = "Never-Gonna-Poop-You-Up-Lyrics"; public Color normalTextColor = Color.black; public Color highlightedTextColor = Color.yellow; private AudioSource audioSource; private List<List<LyricWord>> lyricsLines = new List<List<LyricWord>>(); private List<float> lineEndTimestamps = new List<float>(); private float maxLineWidth; private class LyricWord { public TextMeshProUGUI text; public float startTime; public float endTime; } private void Start() { maxLineWidth = Screen.width; lyricsParent.anchorMin = lyricsParent.anchorMax = new Vector2(0.5f, 0.5f); lyricsParent.pivot = new Vector2(0.5f, 0.5f); lyricsParent.anchoredPosition = Vector2.zero; // Load lyrics from the text file LoadLyrics(); audioSource = gameObject.AddComponent<AudioSource>(); audioSource.clip = audioClip; audioSource.Play(); StartCoroutine(SyncLyrics()); } private List<float> lineTimestamps = new List<float>(); private void LoadLyrics() { TextAsset lyricsFile = Resources.Load<TextAsset>(lyricsFileName); string\[\] lines = lyricsFile.text.Split('\\n'); for (int i = 0; i < lines.Length; i++) { if (lines\[i\].StartsWith("Dialogue:")) { string\[\] parts = lines\[i\].Split(','); // Parse the start timestamp string\[\] startTimeParts = parts\[1\].Split(':'); float startHours = float.Parse(startTimeParts\[0\]); float startMinutes = float.Parse(startTimeParts\[1\]); float startSeconds = float.Parse(startTimeParts\[2\]); float startTimestamp = startHours \* 3600 + startMinutes \* 60 + startSeconds; // Parse the end timestamp string\[\] endTimeParts = parts\[2\].Split(':'); float endHours = float.Parse(endTimeParts\[0\]); float endMinutes = float.Parse(endTimeParts\[1\]); float endSeconds = float.Parse(endTimeParts\[2\]); float endTimestamp = endHours \* 3600 + endMinutes \* 60 + endSeconds; // Add the start and end timestamps to the lists lineTimestamps.Add(startTimestamp); lineEndTimestamps.Add(endTimestamp); // Get the lyrics line text string lyricsLineText = Regex.Match(lines\[i\], @"(?<=^\[^,\]\*(?:,\[^,\]\*){8},).\*$").Value.Trim(); // Check if the line has karaoke mode if (Regex.IsMatch(lyricsLineText, @"\\{\\\\k\\d+\\}")) { // Remove formatting tags (like "{\\k30}") from the text string plainText = Regex.Replace(lyricsLineText, @"\\{\[^}\]\*\\}", ""); // For karaoke lines List<LyricWord> words = CreateLyricsLine(lyricsLineText, startTimestamp, true); // Add the words to the list of lyrics lines lyricsLines.Add(words); } else { // If the line doesn't have karaoke mode, create a single LyricWord for the entire line LyricWord word = new LyricWord { text = CreateTextObject(lyricsLineText, Vector2.zero, false), startTime = startTimestamp, endTime = endTimestamp }; // Add the word to the list of lyrics lines lyricsLines.Add(new List<LyricWord> { word }); } } } } private List<LyricWord> CreateLyricsLine(string inputText, float startTime, bool isKaraokeLine) { List<LyricWord> words = new List<LyricWord>(); MatchCollection wordMatches = Regex.Matches(inputText, @"\\{\\\\k(\\d+)\\}(\[^{\]+)"); float currentTime = startTime; // Add a temporary TextMeshProUGUI object to measure the text width TextMeshProUGUI tempText = CreateTextObject("", Vector2.zero, false); float currentXPosition = 0; float currentYPosition = 0; float scaleFactor = 2.0f; // Same scale factor as in CreateTextObject() foreach (Match wordMatch in wordMatches) { float wordDuration = float.Parse(wordMatch.Groups\[1\].Value) / 100f; string wordText = wordMatch.Groups\[2\].Value; // Measure the text width tempText.text = wordText; float wordWidth = tempText.preferredWidth \* scaleFactor; // Apply the scale factor // Check if there's enough room left on the current line if (currentXPosition + wordWidth > maxLineWidth) { // Move to the next line currentXPosition = 0; currentYPosition -= tempText.preferredHeight + 10; // Add a small space between the lines } // Create the word object with the calculated anchor position LyricWord word = new LyricWord { text = CreateTextObject(wordText, new Vector2(currentXPosition, currentYPosition), isKaraokeLine), startTime = currentTime, endTime = currentTime + wordDuration }; // Add the word to the list of words words.Add(word); // Update the current time and X position currentTime += wordDuration; currentXPosition += wordWidth; // Add a small space between the words currentXPosition += 10; } // Destroy the temporary TextMeshProUGUI object Destroy(tempText.gameObject); // Calculate the total width of the line float lineWidth = CalculateLineWidth(words, scaleFactor); // Calculate the left padding for each word float leftPadding = (maxLineWidth - lineWidth) / 2; // Update the anchor position for each word with the new left padding foreach (LyricWord word in words) { Vector2 anchorPosition = word.text.rectTransform.anchoredPosition; anchorPosition.x += leftPadding; word.text.rectTransform.anchoredPosition = anchorPosition; } return words; } private float CalculateLineWidth(List<LyricWord> words, float scaleFactor) { float totalWidth = 0; foreach (LyricWord word in words) { totalWidth += word.text.preferredWidth \* scaleFactor; } return totalWidth; } private TextMeshProUGUI CreateTextObject(string wordText, Vector2 anchorPosition, bool isKaraokeLine) { GameObject textObj = new GameObject("Lyric Word"); textObj.transform.SetParent(lyricsParent, false); TextMeshProUGUI text = textObj.AddComponent<TextMeshProUGUI>(); // Set the text properties (font, size, color, etc.) here // Adjust the size of the RectTransform RectTransform rectTransform = text.GetComponent<RectTransform>(); rectTransform.anchorMin = rectTransform.anchorMax = new Vector2(0.5f, 1); //rectTransform.sizeDelta = new Vector2(Screen.width, 100); // Set the width to the screen width text.color = normalTextColor; text.enableWordWrapping = !isKaraokeLine; // Disable word wrapping for karaoke if (isKaraokeLine) { text.alignment = TextAlignmentOptions.Left; } else { text.alignment = TextAlignmentOptions.Midline; } // Enable outline and set outline width and color text.fontMaterial.EnableKeyword("OUTLINE\_ON"); text.outlineWidth = 0.2f; text.outlineColor = Color.white; // Scale the text float scaleFactor = 2.0f; // Adjust this value to scale the text text.transform.localScale = new Vector3(scaleFactor, scaleFactor, scaleFactor); // Set font style to bold text.fontStyle = FontStyles.Bold; // Set the anchor position rectTransform.anchoredPosition = anchorPosition; text.text = wordText; return text; } private IEnumerator SyncLyrics() { int currentLineIndex = 0; // Initially, hide all the words foreach (List<LyricWord> words in lyricsLines) { foreach (LyricWord word in words) { word.text.gameObject.SetActive(false); } } while (audioSource.isPlaying) { float currentTime = audioSource.time; // Display the words when their start times are reached if (currentLineIndex < lineTimestamps.Count && currentTime >= lineTimestamps\[currentLineIndex\]) { foreach (LyricWord word in lyricsLines\[currentLineIndex\]) { word.text.gameObject.SetActive(true); StartCoroutine(HighlightWord(word)); } currentLineIndex++; } // Hide the words when their end times are reached for (int i = 0; i < currentLineIndex; i++) { if (currentTime >= lineEndTimestamps\[i\]) { foreach (LyricWord word in lyricsLines\[i\]) { if (word.text.gameObject.activeSelf) { word.text.gameObject.SetActive(false); } } } } yield return null; } } private IEnumerator HighlightWord(LyricWord word) { yield return new WaitForSeconds(word.startTime - audioSource.time); word.text.color = highlightedTextColor; yield return new WaitForSeconds(word.endTime - word.startTime); word.text.color = normalTextColor; } }

1 / 1

To fix the issue of non-karaoke lines not taking up the screen width, you can update the `CreateTextObject` method to set the sizeDelta of the RectTransform depending on whether the line is a karaoke line or not.

Update the `CreateTextObject` method like this:

csharp

```csharp
private TextMeshProUGUI CreateTextObject(string wordText, Vector2 anchorPosition, bool isKaraokeLine)
{
    // ...
    
    // Adjust the size of the RectTransform
    RectTransform rectTransform = text.GetComponent<RectTransform>();
    rectTransform.anchorMin = rectTransform.anchorMax = new Vector2(0.5f, 1);

    if (isKaraokeLine)
    {
        rectTransform.sizeDelta = new Vector2(Screen.width, 100);
    }
    else
    {
        // Set the width to the maxLineWidth
        rectTransform.sizeDelta = new Vector2(maxLineWidth, 100);
    }

    // ...
}
```

Now, non-karaoke lines will also use the same width as the karaoke lines.

> 1 / 1
> 
> Okay that caused the issue of the karaoke lines moving back to the left side of the screen which is strange as maxLineWidth should be the same as Screen.width anyway

1 / 1

I apologize for the confusion. It seems that the issue might be due to the timing when `maxLineWidth` is set in the `Start` method. Let's set the `maxLineWidth` directly in the `CreateTextObject` method to make sure it's set to the correct value when creating both karaoke and non-karaoke lines.

Update the `CreateTextObject` method as follows:

csharp

```csharp
private TextMeshProUGUI CreateTextObject(string wordText, Vector2 anchorPosition, bool isKaraokeLine)
{
    GameObject textObj = new GameObject("Lyric Word");
    textObj.transform.SetParent(lyricsParent, false);
    TextMeshProUGUI text = textObj.AddComponent<TextMeshProUGUI>();

    // ...

    // Adjust the size of the RectTransform
    RectTransform rectTransform = text.GetComponent<RectTransform>();
    rectTransform.anchorMin = rectTransform.anchorMax = new Vector2(0.5f, 1);

    // Set the maxLineWidth here
    float maxLineWidth = Screen.width;

    if (isKaraokeLine)
    {
        rectTransform.sizeDelta = new Vector2(maxLineWidth, 100);
    }
    else
    {
        rectTransform.sizeDelta = new Vector2(maxLineWidth, 100);
    }

    // ...
}
```

By setting the `maxLineWidth` directly in the `CreateTextObject` method, both karaoke and non-karaoke lines should be centered and take up the same width.

> 1 / 1
> 
> Yeah the karaoke lines are centred back on the left side of the screen again now. The non-karaoke lines are fine. Here is the current code: using UnityEngine; using TMPro; using System.Collections; using System.Collections.Generic; using System.Text.RegularExpressions; public class LyricsSynchronizer : MonoBehaviour { public RectTransform lyricsParent; public AudioClip audioClip; public string lyricsFileName = "Never-Gonna-Poop-You-Up-Lyrics"; public Color normalTextColor = Color.black; public Color highlightedTextColor = Color.yellow; private AudioSource audioSource; private List<List<LyricWord>> lyricsLines = new List<List<LyricWord>>(); private List<float> lineEndTimestamps = new List<float>(); private float maxLineWidth; private class LyricWord { public TextMeshProUGUI text; public float startTime; public float endTime; } private void Start() { maxLineWidth = Screen.width; lyricsParent.anchorMin = lyricsParent.anchorMax = new Vector2(0.5f, 0.5f); lyricsParent.pivot = new Vector2(0.5f, 0.5f); lyricsParent.anchoredPosition = Vector2.zero; // Load lyrics from the text file LoadLyrics(); audioSource = gameObject.AddComponent<AudioSource>(); audioSource.clip = audioClip; audioSource.Play(); StartCoroutine(SyncLyrics()); } private List<float> lineTimestamps = new List<float>(); private void LoadLyrics() { TextAsset lyricsFile = Resources.Load<TextAsset>(lyricsFileName); string\[\] lines = lyricsFile.text.Split('\\n'); for (int i = 0; i < lines.Length; i++) { if (lines\[i\].StartsWith("Dialogue:")) { string\[\] parts = lines\[i\].Split(','); // Parse the start timestamp string\[\] startTimeParts = parts\[1\].Split(':'); float startHours = float.Parse(startTimeParts\[0\]); float startMinutes = float.Parse(startTimeParts\[1\]); float startSeconds = float.Parse(startTimeParts\[2\]); float startTimestamp = startHours \* 3600 + startMinutes \* 60 + startSeconds; // Parse the end timestamp string\[\] endTimeParts = parts\[2\].Split(':'); float endHours = float.Parse(endTimeParts\[0\]); float endMinutes = float.Parse(endTimeParts\[1\]); float endSeconds = float.Parse(endTimeParts\[2\]); float endTimestamp = endHours \* 3600 + endMinutes \* 60 + endSeconds; // Add the start and end timestamps to the lists lineTimestamps.Add(startTimestamp); lineEndTimestamps.Add(endTimestamp); // Get the lyrics line text string lyricsLineText = Regex.Match(lines\[i\], @"(?<=^\[^,\]\*(?:,\[^,\]\*){8},).\*$").Value.Trim(); // Check if the line has karaoke mode if (Regex.IsMatch(lyricsLineText, @"\\{\\\\k\\d+\\}")) { // Remove formatting tags (like "{\\k30}") from the text string plainText = Regex.Replace(lyricsLineText, @"\\{\[^}\]\*\\}", ""); // For karaoke lines List<LyricWord> words = CreateLyricsLine(lyricsLineText, startTimestamp, true); // Add the words to the list of lyrics lines lyricsLines.Add(words); } else { // If the line doesn't have karaoke mode, create a single LyricWord for the entire line LyricWord word = new LyricWord { text = CreateTextObject(lyricsLineText, Vector2.zero, false), startTime = startTimestamp, endTime = endTimestamp }; // Add the word to the list of lyrics lines lyricsLines.Add(new List<LyricWord> { word }); } } } } private List<LyricWord> CreateLyricsLine(string inputText, float startTime, bool isKaraokeLine) { List<LyricWord> words = new List<LyricWord>(); MatchCollection wordMatches = Regex.Matches(inputText, @"\\{\\\\k(\\d+)\\}(\[^{\]+)"); float currentTime = startTime; // Add a temporary TextMeshProUGUI object to measure the text width TextMeshProUGUI tempText = CreateTextObject("", Vector2.zero, false); float currentXPosition = 0; float currentYPosition = 0; float scaleFactor = 2.0f; // Same scale factor as in CreateTextObject() foreach (Match wordMatch in wordMatches) { float wordDuration = float.Parse(wordMatch.Groups\[1\].Value) / 100f; string wordText = wordMatch.Groups\[2\].Value; // Measure the text width tempText.text = wordText; float wordWidth = tempText.preferredWidth \* scaleFactor; // Apply the scale factor // Check if there's enough room left on the current line if (currentXPosition + wordWidth > maxLineWidth) { // Move to the next line currentXPosition = 0; currentYPosition -= tempText.preferredHeight + 10; // Add a small space between the lines } // Create the word object with the calculated anchor position LyricWord word = new LyricWord { text = CreateTextObject(wordText, new Vector2(currentXPosition, currentYPosition), isKaraokeLine), startTime = currentTime, endTime = currentTime + wordDuration }; // Add the word to the list of words words.Add(word); // Update the current time and X position currentTime += wordDuration; currentXPosition += wordWidth; // Add a small space between the words currentXPosition += 10; } // Destroy the temporary TextMeshProUGUI object Destroy(tempText.gameObject); // Calculate the total width of the line float lineWidth = CalculateLineWidth(words, scaleFactor); // Calculate the left padding for each word float leftPadding = (maxLineWidth - lineWidth) / 2; // Update the anchor position for each word with the new left padding foreach (LyricWord word in words) { Vector2 anchorPosition = word.text.rectTransform.anchoredPosition; anchorPosition.x += leftPadding; word.text.rectTransform.anchoredPosition = anchorPosition; } return words; } private float CalculateLineWidth(List<LyricWord> words, float scaleFactor) { float totalWidth = 0; foreach (LyricWord word in words) { totalWidth += word.text.preferredWidth \* scaleFactor; } return totalWidth; } private TextMeshProUGUI CreateTextObject(string wordText, Vector2 anchorPosition, bool isKaraokeLine) { GameObject textObj = new GameObject("Lyric Word"); textObj.transform.SetParent(lyricsParent, false); TextMeshProUGUI text = textObj.AddComponent<TextMeshProUGUI>(); // Set the text properties (font, size, color, etc.) here // Set the maxLineWidth here float maxLineWidth = Screen.width; // Adjust the size of the RectTransform RectTransform rectTransform = text.GetComponent<RectTransform>(); rectTransform.anchorMin = rectTransform.anchorMax = new Vector2(0.5f, 1); rectTransform.sizeDelta = new Vector2(maxLineWidth, 100); // Set the width to the screen width text.color = normalTextColor; text.enableWordWrapping = !isKaraokeLine; // Disable word wrapping for karaoke if (isKaraokeLine) { text.alignment = TextAlignmentOptions.Left; } else { text.alignment = TextAlignmentOptions.Midline; } // Enable outline and set outline width and color text.fontMaterial.EnableKeyword("OUTLINE\_ON"); text.outlineWidth = 0.2f; text.outlineColor = Color.white; // Scale the text float scaleFactor = 2.0f; // Adjust this value to scale the text text.transform.localScale = new Vector3(scaleFactor, scaleFactor, scaleFactor); // Set font style to bold text.fontStyle = FontStyles.Bold; // Set the anchor position rectTransform.anchoredPosition = anchorPosition; text.text = wordText; return text; } private IEnumerator SyncLyrics() { int currentLineIndex = 0; // Initially, hide all the words foreach (List<LyricWord> words in lyricsLines) { foreach (LyricWord word in words) { word.text.gameObject.SetActive(false); } } while (audioSource.isPlaying) { float currentTime = audioSource.time; // Display the words when their start times are reached if (currentLineIndex < lineTimestamps.Count && currentTime >= lineTimestamps\[currentLineIndex\]) { foreach (LyricWord word in lyricsLines\[currentLineIndex\]) { word.text.gameObject.SetActive(true); StartCoroutine(HighlightWord(word)); } currentLineIndex++; } // Hide the words when their end times are reached for (int i = 0; i < currentLineIndex; i++) { if (currentTime >= lineEndTimestamps\[i\]) { foreach (LyricWord word in lyricsLines\[i\]) { if (word.text.gameObject.activeSelf) { word.text.gameObject.SetActive(false); } } } } yield return null; } } private IEnumerator HighlightWord(LyricWord word) { yield return new WaitForSeconds(word.startTime - audioSource.time); word.text.color = highlightedTextColor; yield return new WaitForSeconds(word.endTime - word.startTime); word.text.color = normalTextColor; } }

1 / 1

I apologize for the confusion. It seems that the problem is with the center alignment of the karaoke lines. Since we set the alignment to `Left` for karaoke lines, they appear on the left side of the screen.

To fix this, we can remove the `if (isKaraokeLine)` condition in the `CreateTextObject` method and always use the `Midline` alignment, as it seems to be working correctly for the non-karaoke lines.

Here's the updated `CreateTextObject` method:

csharp

```csharp
private TextMeshProUGUI CreateTextObject(string wordText, Vector2 anchorPosition, bool isKaraokeLine)
{
    GameObject textObj = new GameObject("Lyric Word");
    textObj.transform.SetParent(lyricsParent, false);
    TextMeshProUGUI text = textObj.AddComponent<TextMeshProUGUI>();

    // Set the text properties (font, size, color, etc.) here

    // Set the maxLineWidth here
    float maxLineWidth = Screen.width;

    // Adjust the size of the RectTransform
    RectTransform rectTransform = text.GetComponent<RectTransform>();
    rectTransform.anchorMin = rectTransform.anchorMax = new Vector2(0.5f, 1);
    rectTransform.sizeDelta = new Vector2(maxLineWidth, 100); // Set the width to the screen width

    text.color = normalTextColor;
    text.enableWordWrapping = !isKaraokeLine; // Disable word wrapping for karaoke

    // Use Midline alignment for both karaoke and non-karaoke lines
    text.alignment = TextAlignmentOptions.Midline;

    // Enable outline and set outline width and color
    text.fontMaterial.EnableKeyword("OUTLINE_ON");
    text.outlineWidth = 0.2f;
    text.outlineColor = Color.white;

    // Scale the text
    float scaleFactor = 2.0f; // Adjust this value to scale the text
    text.transform.localScale = new Vector3(scaleFactor, scaleFactor, scaleFactor);

    // Set font style to bold
    text.fontStyle = FontStyles.Bold;

    // Set the anchor position
    rectTransform.anchoredPosition = anchorPosition;

    text.text = wordText;

    return text;
}
```

By removing the condition and always using `Midline` alignment, both karaoke and non-karaoke lines should be centered and take up the same width.

> 1 / 1
> 
> Okay that fixed the karaoke line positioning, but now the placements of the words in the line has been messed up, they are kind of jumbled a bit with big spaces between some of them. Here is the current code: using UnityEngine; using TMPro; using System.Collections; using System.Collections.Generic; using System.Text.RegularExpressions; public class LyricsSynchronizer : MonoBehaviour { public RectTransform lyricsParent; public AudioClip audioClip; public string lyricsFileName = "Never-Gonna-Poop-You-Up-Lyrics"; public Color normalTextColor = Color.black; public Color highlightedTextColor = Color.yellow; private AudioSource audioSource; private List<List<LyricWord>> lyricsLines = new List<List<LyricWord>>(); private List<float> lineEndTimestamps = new List<float>(); private float maxLineWidth; private class LyricWord { public TextMeshProUGUI text; public float startTime; public float endTime; } private void Start() { maxLineWidth = Screen.width; lyricsParent.anchorMin = lyricsParent.anchorMax = new Vector2(0.5f, 0.5f); lyricsParent.pivot = new Vector2(0.5f, 0.5f); lyricsParent.anchoredPosition = Vector2.zero; // Load lyrics from the text file LoadLyrics(); audioSource = gameObject.AddComponent<AudioSource>(); audioSource.clip = audioClip; audioSource.Play(); StartCoroutine(SyncLyrics()); } private List<float> lineTimestamps = new List<float>(); private void LoadLyrics() { TextAsset lyricsFile = Resources.Load<TextAsset>(lyricsFileName); string\[\] lines = lyricsFile.text.Split('\\n'); for (int i = 0; i < lines.Length; i++) { if (lines\[i\].StartsWith("Dialogue:")) { string\[\] parts = lines\[i\].Split(','); // Parse the start timestamp string\[\] startTimeParts = parts\[1\].Split(':'); float startHours = float.Parse(startTimeParts\[0\]); float startMinutes = float.Parse(startTimeParts\[1\]); float startSeconds = float.Parse(startTimeParts\[2\]); float startTimestamp = startHours \* 3600 + startMinutes \* 60 + startSeconds; // Parse the end timestamp string\[\] endTimeParts = parts\[2\].Split(':'); float endHours = float.Parse(endTimeParts\[0\]); float endMinutes = float.Parse(endTimeParts\[1\]); float endSeconds = float.Parse(endTimeParts\[2\]); float endTimestamp = endHours \* 3600 + endMinutes \* 60 + endSeconds; // Add the start and end timestamps to the lists lineTimestamps.Add(startTimestamp); lineEndTimestamps.Add(endTimestamp); // Get the lyrics line text string lyricsLineText = Regex.Match(lines\[i\], @"(?<=^\[^,\]\*(?:,\[^,\]\*){8},).\*$").Value.Trim(); // Check if the line has karaoke mode if (Regex.IsMatch(lyricsLineText, @"\\{\\\\k\\d+\\}")) { // Remove formatting tags (like "{\\k30}") from the text string plainText = Regex.Replace(lyricsLineText, @"\\{\[^}\]\*\\}", ""); // For karaoke lines List<LyricWord> words = CreateLyricsLine(lyricsLineText, startTimestamp, true); // Add the words to the list of lyrics lines lyricsLines.Add(words); } else { // If the line doesn't have karaoke mode, create a single LyricWord for the entire line LyricWord word = new LyricWord { text = CreateTextObject(lyricsLineText, Vector2.zero, false), startTime = startTimestamp, endTime = endTimestamp }; // Add the word to the list of lyrics lines lyricsLines.Add(new List<LyricWord> { word }); } } } } private List<LyricWord> CreateLyricsLine(string inputText, float startTime, bool isKaraokeLine) { List<LyricWord> words = new List<LyricWord>(); MatchCollection wordMatches = Regex.Matches(inputText, @"\\{\\\\k(\\d+)\\}(\[^{\]+)"); float currentTime = startTime; // Add a temporary TextMeshProUGUI object to measure the text width TextMeshProUGUI tempText = CreateTextObject("", Vector2.zero, false); float currentXPosition = 0; float currentYPosition = 0; float scaleFactor = 2.0f; // Same scale factor as in CreateTextObject() foreach (Match wordMatch in wordMatches) { float wordDuration = float.Parse(wordMatch.Groups\[1\].Value) / 100f; string wordText = wordMatch.Groups\[2\].Value; // Measure the text width tempText.text = wordText; float wordWidth = tempText.preferredWidth \* scaleFactor; // Apply the scale factor // Check if there's enough room left on the current line if (currentXPosition + wordWidth > maxLineWidth) { // Move to the next line currentXPosition = 0; currentYPosition -= tempText.preferredHeight + 10; // Add a small space between the lines } // Create the word object with the calculated anchor position LyricWord word = new LyricWord { text = CreateTextObject(wordText, new Vector2(currentXPosition, currentYPosition), isKaraokeLine), startTime = currentTime, endTime = currentTime + wordDuration }; // Add the word to the list of words words.Add(word); // Update the current time and X position currentTime += wordDuration; currentXPosition += wordWidth; // Add a small space between the words currentXPosition += 10; } // Destroy the temporary TextMeshProUGUI object Destroy(tempText.gameObject); // Calculate the total width of the line float lineWidth = CalculateLineWidth(words, scaleFactor); // Calculate the left padding for each word float leftPadding = (maxLineWidth - lineWidth) / 2; // Update the anchor position for each word with the new left padding foreach (LyricWord word in words) { Vector2 anchorPosition = word.text.rectTransform.anchoredPosition; anchorPosition.x += leftPadding; word.text.rectTransform.anchoredPosition = anchorPosition; } return words; } private float CalculateLineWidth(List<LyricWord> words, float scaleFactor) { float totalWidth = 0; foreach (LyricWord word in words) { totalWidth += word.text.preferredWidth \* scaleFactor; } return totalWidth; } private TextMeshProUGUI CreateTextObject(string wordText, Vector2 anchorPosition, bool isKaraokeLine) { GameObject textObj = new GameObject("Lyric Word"); textObj.transform.SetParent(lyricsParent, false); TextMeshProUGUI text = textObj.AddComponent<TextMeshProUGUI>(); // Set the text properties (font, size, color, etc.) here // Set the maxLineWidth here float maxLineWidth = Screen.width; // Adjust the size of the RectTransform RectTransform rectTransform = text.GetComponent<RectTransform>(); rectTransform.anchorMin = rectTransform.anchorMax = new Vector2(0.5f, 1); rectTransform.sizeDelta = new Vector2(maxLineWidth, 100); // Set the width to the screen width text.color = normalTextColor; text.enableWordWrapping = !isKaraokeLine; // Disable word wrapping for karaoke if (isKaraokeLine) { text.alignment = TextAlignmentOptions.Midline; } else { text.alignment = TextAlignmentOptions.Midline; } // Enable outline and set outline width and color text.fontMaterial.EnableKeyword("OUTLINE\_ON"); text.outlineWidth = 0.2f; text.outlineColor = Color.white; // Scale the text float scaleFactor = 2.0f; // Adjust this value to scale the text text.transform.localScale = new Vector3(scaleFactor, scaleFactor, scaleFactor); // Set font style to bold text.fontStyle = FontStyles.Bold; // Set the anchor position rectTransform.anchoredPosition = anchorPosition; text.text = wordText; return text; } private IEnumerator SyncLyrics() { int currentLineIndex = 0; // Initially, hide all the words foreach (List<LyricWord> words in lyricsLines) { foreach (LyricWord word in words) { word.text.gameObject.SetActive(false); } } while (audioSource.isPlaying) { float currentTime = audioSource.time; // Display the words when their start times are reached if (currentLineIndex < lineTimestamps.Count && currentTime >= lineTimestamps\[currentLineIndex\]) { foreach (LyricWord word in lyricsLines\[currentLineIndex\]) { word.text.gameObject.SetActive(true); StartCoroutine(HighlightWord(word)); } currentLineIndex++; } // Hide the words when their end times are reached for (int i = 0; i < currentLineIndex; i++) { if (currentTime >= lineEndTimestamps\[i\]) { foreach (LyricWord word in lyricsLines\[i\]) { if (word.text.gameObject.activeSelf) { word.text.gameObject.SetActive(false); } } } } yield return null; } } private IEnumerator HighlightWord(LyricWord word) { yield return new WaitForSeconds(word.startTime - audioSource.time); word.text.color = highlightedTextColor; yield return new WaitForSeconds(word.endTime - word.startTime); word.text.color = normalTextColor; } }

1 / 1

The issue is that when calculating the lineWidth and adding space between the words, the scale factor is being applied multiple times, causing the jumbled appearance. To fix this, update the `CalculateLineWidth` method to not include the scale factor and remove the addition of space between words from the `CreateLyricsLine` method. The modified code is shown below:

Replace the `CalculateLineWidth` method with the following:

csharp

```csharp
private float CalculateLineWidth(List<LyricWord> words)
{
    float totalWidth = 0;
    foreach (LyricWord word in words)
    {
        totalWidth += word.text.preferredWidth;
    }
    return totalWidth;
}
```

In the `CreateLyricsLine` method, update the following line:

csharp

```csharp
float lineWidth = CalculateLineWidth(words, scaleFactor);
```

to

csharp

```csharp
float lineWidth = CalculateLineWidth(words);
```

Lastly, remove the following line in the same method:

csharp

```csharp
currentXPosition += 10;
```

This should fix the issue of jumbled text and large spaces between words.

> 1 / 1
> 
> No, that looks terrible now - we need the scaling option since the scaling is being applied to the text. Just to confirm, the position of the karaoke words in the line was great when we had the Left positioning but had moved the line around in the Start function (but the non-karaoke lines were not the correct width) I have reverted the code, here it is again: using UnityEngine; using TMPro; using System.Collections; using System.Collections.Generic; using System.Text.RegularExpressions; public class LyricsSynchronizer : MonoBehaviour { public RectTransform lyricsParent; public AudioClip audioClip; public string lyricsFileName = "Never-Gonna-Poop-You-Up-Lyrics"; public Color normalTextColor = Color.black; public Color highlightedTextColor = Color.yellow; private AudioSource audioSource; private List<List<LyricWord>> lyricsLines = new List<List<LyricWord>>(); private List<float> lineEndTimestamps = new List<float>(); private float maxLineWidth; private class LyricWord { public TextMeshProUGUI text; public float startTime; public float endTime; } private void Start() { maxLineWidth = Screen.width; lyricsParent.anchorMin = lyricsParent.anchorMax = new Vector2(0.5f, 0.5f); lyricsParent.pivot = new Vector2(0.5f, 0.5f); lyricsParent.anchoredPosition = Vector2.zero; // Load lyrics from the text file LoadLyrics(); audioSource = gameObject.AddComponent<AudioSource>(); audioSource.clip = audioClip; audioSource.Play(); StartCoroutine(SyncLyrics()); } private List<float> lineTimestamps = new List<float>(); private void LoadLyrics() { TextAsset lyricsFile = Resources.Load<TextAsset>(lyricsFileName); string\[\] lines = lyricsFile.text.Split('\\n'); for (int i = 0; i < lines.Length; i++) { if (lines\[i\].StartsWith("Dialogue:")) { string\[\] parts = lines\[i\].Split(','); // Parse the start timestamp string\[\] startTimeParts = parts\[1\].Split(':'); float startHours = float.Parse(startTimeParts\[0\]); float startMinutes = float.Parse(startTimeParts\[1\]); float startSeconds = float.Parse(startTimeParts\[2\]); float startTimestamp = startHours \* 3600 + startMinutes \* 60 + startSeconds; // Parse the end timestamp string\[\] endTimeParts = parts\[2\].Split(':'); float endHours = float.Parse(endTimeParts\[0\]); float endMinutes = float.Parse(endTimeParts\[1\]); float endSeconds = float.Parse(endTimeParts\[2\]); float endTimestamp = endHours \* 3600 + endMinutes \* 60 + endSeconds; // Add the start and end timestamps to the lists lineTimestamps.Add(startTimestamp); lineEndTimestamps.Add(endTimestamp); // Get the lyrics line text string lyricsLineText = Regex.Match(lines\[i\], @"(?<=^\[^,\]\*(?:,\[^,\]\*){8},).\*$").Value.Trim(); // Check if the line has karaoke mode if (Regex.IsMatch(lyricsLineText, @"\\{\\\\k\\d+\\}")) { // Remove formatting tags (like "{\\k30}") from the text string plainText = Regex.Replace(lyricsLineText, @"\\{\[^}\]\*\\}", ""); // For karaoke lines List<LyricWord> words = CreateLyricsLine(lyricsLineText, startTimestamp, true); // Add the words to the list of lyrics lines lyricsLines.Add(words); } else { // If the line doesn't have karaoke mode, create a single LyricWord for the entire line LyricWord word = new LyricWord { text = CreateTextObject(lyricsLineText, Vector2.zero, false), startTime = startTimestamp, endTime = endTimestamp }; // Add the word to the list of lyrics lines lyricsLines.Add(new List<LyricWord> { word }); } } } } private List<LyricWord> CreateLyricsLine(string inputText, float startTime, bool isKaraokeLine) { List<LyricWord> words = new List<LyricWord>(); MatchCollection wordMatches = Regex.Matches(inputText, @"\\{\\\\k(\\d+)\\}(\[^{\]+)"); float currentTime = startTime; // Add a temporary TextMeshProUGUI object to measure the text width TextMeshProUGUI tempText = CreateTextObject("", Vector2.zero, false); float currentXPosition = 0; float currentYPosition = 0; float scaleFactor = 2.0f; // Same scale factor as in CreateTextObject() foreach (Match wordMatch in wordMatches) { float wordDuration = float.Parse(wordMatch.Groups\[1\].Value) / 100f; string wordText = wordMatch.Groups\[2\].Value; // Measure the text width tempText.text = wordText; float wordWidth = tempText.preferredWidth \* scaleFactor; // Apply the scale factor // Check if there's enough room left on the current line if (currentXPosition + wordWidth > maxLineWidth) { // Move to the next line currentXPosition = 0; currentYPosition -= tempText.preferredHeight + 10; // Add a small space between the lines } // Create the word object with the calculated anchor position LyricWord word = new LyricWord { text = CreateTextObject(wordText, new Vector2(currentXPosition, currentYPosition), isKaraokeLine), startTime = currentTime, endTime = currentTime + wordDuration }; // Add the word to the list of words words.Add(word); // Update the current time and X position currentTime += wordDuration; currentXPosition += wordWidth; // Add a small space between the words currentXPosition += 10; } // Destroy the temporary TextMeshProUGUI object Destroy(tempText.gameObject); // Calculate the total width of the line float lineWidth = CalculateLineWidth(words, scaleFactor); // Calculate the left padding for each word float leftPadding = (maxLineWidth - lineWidth) / 2; // Update the anchor position for each word with the new left padding foreach (LyricWord word in words) { Vector2 anchorPosition = word.text.rectTransform.anchoredPosition; anchorPosition.x += leftPadding; word.text.rectTransform.anchoredPosition = anchorPosition; } return words; } private float CalculateLineWidth(List<LyricWord> words, float scaleFactor) { float totalWidth = 0; foreach (LyricWord word in words) { totalWidth += word.text.preferredWidth \* scaleFactor; } return totalWidth; } private TextMeshProUGUI CreateTextObject(string wordText, Vector2 anchorPosition, bool isKaraokeLine) { GameObject textObj = new GameObject("Lyric Word"); textObj.transform.SetParent(lyricsParent, false); TextMeshProUGUI text = textObj.AddComponent<TextMeshProUGUI>(); // Set the text properties (font, size, color, etc.) here // Set the maxLineWidth here float maxLineWidth = Screen.width; // Adjust the size of the RectTransform RectTransform rectTransform = text.GetComponent<RectTransform>(); rectTransform.anchorMin = rectTransform.anchorMax = new Vector2(0.5f, 1); rectTransform.sizeDelta = new Vector2(maxLineWidth, 100); // Set the width to the screen width text.color = normalTextColor; text.enableWordWrapping = !isKaraokeLine; // Disable word wrapping for karaoke if (isKaraokeLine) { text.alignment = TextAlignmentOptions.Midline; } else { text.alignment = TextAlignmentOptions.Midline; } // Enable outline and set outline width and color text.fontMaterial.EnableKeyword("OUTLINE\_ON"); text.outlineWidth = 0.2f; text.outlineColor = Color.white; // Scale the text float scaleFactor = 2.0f; // Adjust this value to scale the text text.transform.localScale = new Vector3(scaleFactor, scaleFactor, scaleFactor); // Set font style to bold text.fontStyle = FontStyles.Bold; // Set the anchor position rectTransform.anchoredPosition = anchorPosition; text.text = wordText; return text; } private IEnumerator SyncLyrics() { int currentLineIndex = 0; // Initially, hide all the words foreach (List<LyricWord> words in lyricsLines) { foreach (LyricWord word in words) { word.text.gameObject.SetActive(false); } } while (audioSource.isPlaying) { float currentTime = audioSource.time; // Display the words when their start times are reached if (currentLineIndex < lineTimestamps.Count && currentTime >= lineTimestamps\[currentLineIndex\]) { foreach (LyricWord word in lyricsLines\[currentLineIndex\]) { word.text.gameObject.SetActive(true); StartCoroutine(HighlightWord(word)); } currentLineIndex++; } // Hide the words when their end times are reached for (int i = 0; i < currentLineIndex; i++) { if (currentTime >= lineEndTimestamps\[i\]) { foreach (LyricWord word in lyricsLines\[i\]) { if (word.text.gameObject.activeSelf) { word.text.gameObject.SetActive(false); } } } } yield return null; } } private IEnumerator HighlightWord(LyricWord word) { yield return new WaitForSeconds(word.startTime - audioSource.time); word.text.color = highlightedTextColor; yield return new WaitForSeconds(word.endTime - word.startTime); word.text.color = normalTextColor; } }

1 / 1

Thank you for reverting the code. Here's the updated version that applies the scaling option to the text and keeps the left positioning with the line moved around in the Start function:

csharp

```csharp
using UnityEngine;
using TMPro;
using System.Collections;
using System.Collections.Generic;
using System.Text.RegularExpressions;

public class LyricsSynchronizer : MonoBehaviour
{
    public RectTransform lyricsParent;
    public AudioClip audioClip;
    public string lyricsFileName = "Never-Gonna-Poop-You-Up-Lyrics";
    public Color normalTextColor = Color.black;
    public Color highlightedTextColor = Color.yellow;

    private AudioSource audioSource;
    private List<List<LyricWord>> lyricsLines = new List<List<LyricWord>>();
    private List<float> lineEndTimestamps = new List<float>();

    private float maxLineWidth;

    private class LyricWord
    {
        public TextMeshProUGUI text;
        public float startTime;
        public float endTime;
    }

    private void Start()
    {
        maxLineWidth = Screen.width * 0.9f; // Adjust this value to set the maximum width of a line

        lyricsParent.anchorMin = lyricsParent.anchorMax = new Vector2(0.5f, 0.5f);
        lyricsParent.pivot = new Vector2(0.5f, 0.5f);
        lyricsParent.anchoredPosition = Vector2.zero;

        // Load lyrics from the text file
        LoadLyrics();

        audioSource = gameObject.AddComponent<AudioSource>();
        audioSource.clip = audioClip;
        audioSource.Play();

        StartCoroutine(SyncLyrics());
    }

    // ... (rest of the code remains unchanged)

    private TextMeshProUGUI CreateTextObject(string wordText, Vector2 anchorPosition, bool isKaraokeLine)
    {
        GameObject textObj = new GameObject("Lyric Word");
        textObj.transform.SetParent(lyricsParent, false);
        TextMeshProUGUI text = textObj.AddComponent<TextMeshProUGUI>();

        // Set the text properties (font, size, color, etc.) here

        // Adjust the size of the RectTransform
        RectTransform rectTransform = text.GetComponent<RectTransform>();
        rectTransform.anchorMin = rectTransform.anchorMax = new Vector2(0.5f, 1);
        rectTransform.sizeDelta = new Vector2(maxLineWidth, 100); // Set the width to the maxLineWidth

        text.color = normalTextColor;
        text.enableWordWrapping = !isKaraokeLine; // Disable word wrapping for karaoke
        if (isKaraokeLine)
        {
            text.alignment = TextAlignmentOptions.Left;
        }
        else
        {
            text.alignment = TextAlignmentOptions.Left;
        }

        // Enable outline and set outline width and color
        text.fontMaterial.EnableKeyword("OUTLINE_ON");
        text.outlineWidth = 0.2f;
        text.outlineColor = Color.white;

        // Scale the text
        float scaleFactor = 2.0f; // Adjust this value to scale the text
        text.transform.localScale = new Vector3(scaleFactor, scaleFactor, scaleFactor);

        // Set font style to bold
        text.fontStyle = FontStyles.Bold;

        // Set the anchor position
        rectTransform.anchoredPosition = anchorPosition;

        text.text = wordText;

        return text;
    }

    // ... (rest of the code remains unchanged)
}
```

The updated code now keeps the left positioning with the line moved around in the Start function and applies the scaling option to the text.

> 1 / 1
> 
> No that didn't fix it. I have reverted the code. With the following code the karaoke lines are still drawn with the line centres being the left edge of the screen, and the non-karaoke lines are centred correctly. Is there anything more you need to help debug? I could add some debug messages to assist.

1 / 1

I apologize for the confusion. In the previous version of the code, I didn't fully understand the issue. To clarify, the non-karaoke lines are correctly centered, but the karaoke lines are not.

To debug and fix the issue, let's add debug messages to the `CreateLyricsLine` method, which handles the karaoke lines, to check the calculated `leftPadding` value and `currentXPosition` before and after updating it with the left padding. Also, let's add debug messages to the `CreateTextObject` method to check the `anchorPosition` value for karaoke and non-karaoke lines.

Please add the following debug messages to the code:

1.  In the `CreateLyricsLine` method, after calculating the `leftPadding` value:

csharp

```csharp
Debug.Log("Left Padding: " + leftPadding);
```

2.  In the `CreateLyricsLine` method, before updating the `anchorPosition` with the new left padding:

csharp

```csharp
Debug.Log("Current X Position before padding: " + anchorPosition.x);
```

3.  In the `CreateLyricsLine` method, after updating the `anchorPosition` with the new left padding:

csharp

```csharp
Debug.Log("Current X Position after padding: " + anchorPosition.x);
```

4.  In the `CreateTextObject` method, after setting the `anchorPosition` value:

csharp

```csharp
Debug.Log("Anchor Position: " + anchorPosition);
```

After adding these debug messages, run the code and observe the values printed in the console. This should help us understand the issue better and find a solution.

> 1 / 1
> 
> This is the result, how can we identify which line added which debug? Anchor Position: (0.00, 0.00) UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateTextObject (string,UnityEngine.Vector2,bool) (at Assets/scripts/LyricsSynchronizer.cs:232) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:94) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Anchor Position: (0.00, 0.00) UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateTextObject (string,UnityEngine.Vector2,bool) (at Assets/scripts/LyricsSynchronizer.cs:232) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:116) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Anchor Position: (0.00, 0.00) UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateTextObject (string,UnityEngine.Vector2,bool) (at Assets/scripts/LyricsSynchronizer.cs:232) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:140) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Anchor Position: (219.38, 0.00) UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateTextObject (string,UnityEngine.Vector2,bool) (at Assets/scripts/LyricsSynchronizer.cs:232) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:140) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Anchor Position: (314.80, 0.00) UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateTextObject (string,UnityEngine.Vector2,bool) (at Assets/scripts/LyricsSynchronizer.cs:232) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:140) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Anchor Position: (666.52, 0.00) UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateTextObject (string,UnityEngine.Vector2,bool) (at Assets/scripts/LyricsSynchronizer.cs:232) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:140) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Anchor Position: (741.84, 0.00) UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateTextObject (string,UnityEngine.Vector2,bool) (at Assets/scripts/LyricsSynchronizer.cs:232) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:140) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Anchor Position: (0.00, -50.22) UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateTextObject (string,UnityEngine.Vector2,bool) (at Assets/scripts/LyricsSynchronizer.cs:232) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:140) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Anchor Position: (225.26, -50.22) UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateTextObject (string,UnityEngine.Vector2,bool) (at Assets/scripts/LyricsSynchronizer.cs:232) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:140) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Anchor Position: (360.04, -50.22) UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateTextObject (string,UnityEngine.Vector2,bool) (at Assets/scripts/LyricsSynchronizer.cs:232) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:140) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Left Padding: -217.4901 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:166) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Current X Position before padding: 0 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:172) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Current X Position after padding: -217.4901 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:174) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Current X Position before padding: 219.38 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:172) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Current X Position after padding: 1.889954 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:174) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Current X Position before padding: 314.8 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:172) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Current X Position after padding: 97.30994 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:174) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Current X Position before padding: 666.52 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:172) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Current X Position after padding: 449.03 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:174) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Current X Position before padding: 741.84 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:172) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Current X Position after padding: 524.35 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:174) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Current X Position before padding: 225.26 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:172) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Current X Position after padding: 7.769943 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:174) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Current X Position before padding: 360.04 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:172) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Current X Position after padding: 142.5499 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:174) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37)

1 / 1

Based on the debug log, it seems like the issue is with the `leftPadding` value calculation in the `CreateLyricsLine` method. The `leftPadding` value becomes negative, which causes the `anchorPosition` to move to the left, off the screen.

Here is an updated version of the `CreateLyricsLine` method that calculates the `leftPadding` differently. This should fix the issue:

csharp

```csharp
private void CreateLyricsLine(string line, float timestamp, bool isKaraokeLine)
{
    Vector2 anchorPosition = new Vector2(0, currentYPosition);

    if (isKaraokeLine)
    {
        string[] words = line.Split(' ');
        float currentXPosition = 0;

        for (int i = 0; i < words.Length; i++)
        {
            GameObject wordObject = CreateTextObject(words[i], anchorPosition, true);
            wordObject.GetComponent<RectTransform>().anchoredPosition = new Vector2(currentXPosition, currentYPosition);

            float wordWidth = wordObject.GetComponent<RectTransform>().sizeDelta.x;
            currentXPosition += wordWidth;

            if (i < words.Length - 1)
            {
                GameObject spaceObject = CreateTextObject(" ", anchorPosition, true);
                spaceObject.GetComponent<RectTransform>().anchoredPosition = new Vector2(currentXPosition, currentYPosition);

                float spaceWidth = spaceObject.GetComponent<RectTransform>().sizeDelta.x;
                currentXPosition += spaceWidth;
            }
        }

        float totalLineWidth = currentXPosition;
        float leftPadding = (Screen.width - totalLineWidth) / 2;

        if (leftPadding < 0) leftPadding = 0; // Ensure leftPadding is not negative

        // Update the anchorPosition for each word and space in the karaoke line
        for (int i = 0; i < words.Length * 2 - 1; i++)
        {
            GameObject textObject = lyricsContent.GetChild(lyricsContent.childCount - i - 1).gameObject;
            Vector2 currentObjectAnchorPosition = textObject.GetComponent<RectTransform>().anchoredPosition;
            textObject.GetComponent<RectTransform>().anchoredPosition = new Vector2(currentObjectAnchorPosition.x + leftPadding, currentObjectAnchorPosition.y);
        }
    }
    else
    {
        CreateTextObject(line, anchorPosition, false);
    }

    currentYPosition -= lineHeight;
}
```

This updated version of the method calculates the `leftPadding` value based on the total line width and ensures that it is not negative. It should now correctly center the karaoke lines on the screen.

> 1 / 1
> 
> Now I get these errors: Assets\\scripts\\LyricsSynchronizer.cs(86,45): error CS0029: Cannot implicitly convert type 'void' to 'System.Collections.Generic.List<LyricsSynchronizer.LyricWord>' Assets\\scripts\\LyricsSynchronizer.cs(110,49): error CS0103: The name 'currentYPosition' does not exist in the current context Assets\\scripts\\LyricsSynchronizer.cs(119,41): error CS0029: Cannot implicitly convert type 'TMPro.TextMeshProUGUI' to 'UnityEngine.GameObject' Assets\\scripts\\LyricsSynchronizer.cs(120,107): error CS0103: The name 'currentYPosition' does not exist in the current context Assets\\scripts\\LyricsSynchronizer.cs(127,46): error CS0029: Cannot implicitly convert type 'TMPro.TextMeshProUGUI' to 'UnityEngine.GameObject' Assets\\scripts\\LyricsSynchronizer.cs(128,112): error CS0103: The name 'currentYPosition' does not exist in the current context Assets\\scripts\\LyricsSynchronizer.cs(143,41): error CS0103: The name 'lyricsContent' does not exist in the current context Assets\\scripts\\LyricsSynchronizer.cs(143,64): error CS0103: The name 'lyricsContent' does not exist in the current context Assets\\scripts\\LyricsSynchronizer.cs(153,9): error CS0103: The name 'currentYPosition' does not exist in the current context Assets\\scripts\\LyricsSynchronizer.cs(153,29): error CS0103: The name 'lineHeight' does not exist in the current context Here is the code for reference: using UnityEngine; using TMPro; using System.Collections; using System.Collections.Generic; using System.Text.RegularExpressions; public class LyricsSynchronizer : MonoBehaviour { public RectTransform lyricsParent; public AudioClip audioClip; public string lyricsFileName = "Never-Gonna-Poop-You-Up-Lyrics"; public Color normalTextColor = Color.black; public Color highlightedTextColor = Color.yellow; private AudioSource audioSource; private List<List<LyricWord>> lyricsLines = new List<List<LyricWord>>(); private List<float> lineEndTimestamps = new List<float>(); private float maxLineWidth; private class LyricWord { public TextMeshProUGUI text; public float startTime; public float endTime; } private void Start() { maxLineWidth = Screen.width; lyricsParent.anchorMin = lyricsParent.anchorMax = new Vector2(0.5f, 0.5f); lyricsParent.pivot = new Vector2(0.5f, 0.5f); lyricsParent.anchoredPosition = Vector2.zero; // Load lyrics from the text file LoadLyrics(); audioSource = gameObject.AddComponent<AudioSource>(); audioSource.clip = audioClip; audioSource.Play(); StartCoroutine(SyncLyrics()); } private List<float> lineTimestamps = new List<float>(); private void LoadLyrics() { TextAsset lyricsFile = Resources.Load<TextAsset>(lyricsFileName); string\[\] lines = lyricsFile.text.Split('\\n'); for (int i = 0; i < lines.Length; i++) { if (lines\[i\].StartsWith("Dialogue:")) { string\[\] parts = lines\[i\].Split(','); // Parse the start timestamp string\[\] startTimeParts = parts\[1\].Split(':'); float startHours = float.Parse(startTimeParts\[0\]); float startMinutes = float.Parse(startTimeParts\[1\]); float startSeconds = float.Parse(startTimeParts\[2\]); float startTimestamp = startHours \* 3600 + startMinutes \* 60 + startSeconds; // Parse the end timestamp string\[\] endTimeParts = parts\[2\].Split(':'); float endHours = float.Parse(endTimeParts\[0\]); float endMinutes = float.Parse(endTimeParts\[1\]); float endSeconds = float.Parse(endTimeParts\[2\]); float endTimestamp = endHours \* 3600 + endMinutes \* 60 + endSeconds; // Add the start and end timestamps to the lists lineTimestamps.Add(startTimestamp); lineEndTimestamps.Add(endTimestamp); // Get the lyrics line text string lyricsLineText = Regex.Match(lines\[i\], @"(?<=^\[^,\]\*(?:,\[^,\]\*){8},).\*$").Value.Trim(); // Check if the line has karaoke mode if (Regex.IsMatch(lyricsLineText, @"\\{\\\\k\\d+\\}")) { // Remove formatting tags (like "{\\k30}") from the text string plainText = Regex.Replace(lyricsLineText, @"\\{\[^}\]\*\\}", ""); // For karaoke lines List<LyricWord> words = CreateLyricsLine(lyricsLineText, startTimestamp, true); // Add the words to the list of lyrics lines lyricsLines.Add(words); } else { // If the line doesn't have karaoke mode, create a single LyricWord for the entire line LyricWord word = new LyricWord { text = CreateTextObject(lyricsLineText, Vector2.zero, false), startTime = startTimestamp, endTime = endTimestamp }; // Add the word to the list of lyrics lines lyricsLines.Add(new List<LyricWord> { word }); } } } } private void CreateLyricsLine(string line, float timestamp, bool isKaraokeLine) { Vector2 anchorPosition = new Vector2(0, currentYPosition); if (isKaraokeLine) { string\[\] words = line.Split(' '); float currentXPosition = 0; for (int i = 0; i < words.Length; i++) { GameObject wordObject = CreateTextObject(words\[i\], anchorPosition, true); wordObject.GetComponent<RectTransform>().anchoredPosition = new Vector2(currentXPosition, currentYPosition); float wordWidth = wordObject.GetComponent<RectTransform>().sizeDelta.x; currentXPosition += wordWidth; if (i < words.Length - 1) { GameObject spaceObject = CreateTextObject(" ", anchorPosition, true); spaceObject.GetComponent<RectTransform>().anchoredPosition = new Vector2(currentXPosition, currentYPosition); float spaceWidth = spaceObject.GetComponent<RectTransform>().sizeDelta.x; currentXPosition += spaceWidth; } } float totalLineWidth = currentXPosition; float leftPadding = (Screen.width - totalLineWidth) / 2; if (leftPadding < 0) leftPadding = 0; // Ensure leftPadding is not negative // Update the anchorPosition for each word and space in the karaoke line for (int i = 0; i < words.Length \* 2 - 1; i++) { GameObject textObject = lyricsContent.GetChild(lyricsContent.childCount - i - 1).gameObject; Vector2 currentObjectAnchorPosition = textObject.GetComponent<RectTransform>().anchoredPosition; textObject.GetComponent<RectTransform>().anchoredPosition = new Vector2(currentObjectAnchorPosition.x + leftPadding, currentObjectAnchorPosition.y); } } else { CreateTextObject(line, anchorPosition, false); } currentYPosition -= lineHeight; } private float CalculateLineWidth(List<LyricWord> words, float scaleFactor) { float totalWidth = 0; foreach (LyricWord word in words) { totalWidth += word.text.preferredWidth \* scaleFactor; } return totalWidth; } private TextMeshProUGUI CreateTextObject(string wordText, Vector2 anchorPosition, bool isKaraokeLine) { GameObject textObj = new GameObject("Lyric Word"); textObj.transform.SetParent(lyricsParent, false); TextMeshProUGUI text = textObj.AddComponent<TextMeshProUGUI>(); // Set the text properties (font, size, color, etc.) here // Set the maxLineWidth here float maxLineWidth = Screen.width; // Adjust the size of the RectTransform RectTransform rectTransform = text.GetComponent<RectTransform>(); rectTransform.anchorMin = rectTransform.anchorMax = new Vector2(0.5f, 1); rectTransform.sizeDelta = new Vector2(maxLineWidth, 100); // Set the width to the screen width text.color = normalTextColor; text.enableWordWrapping = !isKaraokeLine; // Disable word wrapping for karaoke if (isKaraokeLine) { text.alignment = TextAlignmentOptions.Left; } else { text.alignment = TextAlignmentOptions.Midline; } // Enable outline and set outline width and color text.fontMaterial.EnableKeyword("OUTLINE\_ON"); text.outlineWidth = 0.2f; text.outlineColor = Color.white; // Scale the text float scaleFactor = 2.0f; // Adjust this value to scale the text text.transform.localScale = new Vector3(scaleFactor, scaleFactor, scaleFactor); // Set font style to bold text.fontStyle = FontStyles.Bold; // Set the anchor position rectTransform.anchoredPosition = anchorPosition; Debug.Log("Anchor Position: " + anchorPosition); text.text = wordText; return text; } private IEnumerator SyncLyrics() { int currentLineIndex = 0; // Initially, hide all the words foreach (List<LyricWord> words in lyricsLines) { foreach (LyricWord word in words) { word.text.gameObject.SetActive(false); } } while (audioSource.isPlaying) { float currentTime = audioSource.time; // Display the words when their start times are reached if (currentLineIndex < lineTimestamps.Count && currentTime >= lineTimestamps\[currentLineIndex\]) { foreach (LyricWord word in lyricsLines\[currentLineIndex\]) { word.text.gameObject.SetActive(true); StartCoroutine(HighlightWord(word)); } currentLineIndex++; } // Hide the words when their end times are reached for (int i = 0; i < currentLineIndex; i++) { if (currentTime >= lineEndTimestamps\[i\]) { foreach (LyricWord word in lyricsLines\[i\]) { if (word.text.gameObject.activeSelf) { word.text.gameObject.SetActive(false); } } } } yield return null; } } private IEnumerator HighlightWord(LyricWord word) { yield return new WaitForSeconds(word.startTime - audioSource.time); word.text.color = highlightedTextColor; yield return new WaitForSeconds(word.endTime - word.startTime); word.text.color = normalTextColor; } }

1 / 1

There are several issues with the code you provided. Here are the fixes for each error:

1.  In the `LoadLyrics()` function, the return type of the `CreateLyricsLine()` function should be `List<LyricWord>` instead of `void`. Update the function definition as follows:

csharp

```csharp
private List<LyricWord> CreateLyricsLine(string line, float timestamp, bool isKaraokeLine)
```

2.  Declare `currentYPosition` and `lineHeight` as class-level variables:

csharp

```csharp
private float currentYPosition = 0;
private float lineHeight = 50;
```

3.  In the `CreateTextObject()` function, change the return type of the function to `GameObject` and return `textObj` instead of `text`:

csharp

```csharp
private GameObject CreateTextObject(string wordText, Vector2 anchorPosition, bool isKaraokeLine)
{
    //...
    return textObj;
}
```

4.  Update the usage of `CreateTextObject()` in the `LoadLyrics()` function and other places:

csharp

```csharp
TextMeshProUGUI textComponent = wordObject.GetComponent<TextMeshProUGUI>();
```

5.  In the `CreateLyricsLine()` function, replace the usage of `lyricsContent` with `lyricsParent`. Remove the `lyricsContent` variable as it doesn't exist in the current context:

csharp

```csharp
GameObject textObject = lyricsParent.GetChild(lyricsParent.childCount - i - 1).gameObject;
```

6.  Update the `CreateLyricsLine()` function to return a `List<LyricWord>` instead of `void`. Initialize a new list and add each created `LyricWord` object to it:

csharp

```csharp
private List<LyricWord> CreateLyricsLine(string line, float timestamp, bool isKaraokeLine)
{
    List<LyricWord> lyricWords = new List<LyricWord>();

    //...
    // Inside the loop for creating wordObjects
    LyricWord word = new LyricWord
    {
        text = wordObject.GetComponent<TextMeshProUGUI>(),
        startTime = 0, // Set the appropriate startTime value
        endTime = 0 // Set the appropriate endTime value
    };
    lyricWords.Add(word);

    //...
    // At the end of the function
    return lyricWords;
}
```

7.  Replace the call to `CreateLyricsLine()` in the `LoadLyrics()` function with the following code:

csharp

```csharp
List<LyricWord> words = CreateLyricsLine(lyricsLineText, startTimestamp, true);
lyricsLines.Add(words);
```

After applying these fixes, the code should compile without errors. Note that you may need to adjust the `startTime` and `endTime` values for each `LyricWord` in the `CreateLyricsLine()` function, as they are currently set to 0.

> 2 / 2
> 
> ignore my last message. Let's revert to the previous code after adding the debug messages. We are trying to figure out what is going on with the karaoke lines being drawn on the left side of the screen. Here is the code: using UnityEngine; using TMPro; using System.Collections; using System.Collections.Generic; using System.Text.RegularExpressions; public class LyricsSynchronizer : MonoBehaviour { public RectTransform lyricsParent; public AudioClip audioClip; public string lyricsFileName = "Never-Gonna-Poop-You-Up-Lyrics"; public Color normalTextColor = Color.black; public Color highlightedTextColor = Color.yellow; private AudioSource audioSource; private List<List<LyricWord>> lyricsLines = new List<List<LyricWord>>(); private List<float> lineEndTimestamps = new List<float>(); private float maxLineWidth; private class LyricWord { public TextMeshProUGUI text; public float startTime; public float endTime; } private void Start() { maxLineWidth = Screen.width; lyricsParent.anchorMin = lyricsParent.anchorMax = new Vector2(0.5f, 0.5f); lyricsParent.pivot = new Vector2(0.5f, 0.5f); lyricsParent.anchoredPosition = Vector2.zero; // Load lyrics from the text file LoadLyrics(); audioSource = gameObject.AddComponent<AudioSource>(); audioSource.clip = audioClip; audioSource.Play(); StartCoroutine(SyncLyrics()); } private List<float> lineTimestamps = new List<float>(); private void LoadLyrics() { TextAsset lyricsFile = Resources.Load<TextAsset>(lyricsFileName); string\[\] lines = lyricsFile.text.Split('\\n'); for (int i = 0; i < lines.Length; i++) { if (lines\[i\].StartsWith("Dialogue:")) { string\[\] parts = lines\[i\].Split(','); // Parse the start timestamp string\[\] startTimeParts = parts\[1\].Split(':'); float startHours = float.Parse(startTimeParts\[0\]); float startMinutes = float.Parse(startTimeParts\[1\]); float startSeconds = float.Parse(startTimeParts\[2\]); float startTimestamp = startHours \* 3600 + startMinutes \* 60 + startSeconds; // Parse the end timestamp string\[\] endTimeParts = parts\[2\].Split(':'); float endHours = float.Parse(endTimeParts\[0\]); float endMinutes = float.Parse(endTimeParts\[1\]); float endSeconds = float.Parse(endTimeParts\[2\]); float endTimestamp = endHours \* 3600 + endMinutes \* 60 + endSeconds; // Add the start and end timestamps to the lists lineTimestamps.Add(startTimestamp); lineEndTimestamps.Add(endTimestamp); // Get the lyrics line text string lyricsLineText = Regex.Match(lines\[i\], @"(?<=^\[^,\]\*(?:,\[^,\]\*){8},).\*$").Value.Trim(); // Check if the line has karaoke mode if (Regex.IsMatch(lyricsLineText, @"\\{\\\\k\\d+\\}")) { // Remove formatting tags (like "{\\k30}") from the text string plainText = Regex.Replace(lyricsLineText, @"\\{\[^}\]\*\\}", ""); // For karaoke lines List<LyricWord> words = CreateLyricsLine(lyricsLineText, startTimestamp, true); // Add the words to the list of lyrics lines lyricsLines.Add(words); } else { // If the line doesn't have karaoke mode, create a single LyricWord for the entire line LyricWord word = new LyricWord { text = CreateTextObject(lyricsLineText, Vector2.zero, false), startTime = startTimestamp, endTime = endTimestamp }; // Add the word to the list of lyrics lines lyricsLines.Add(new List<LyricWord> { word }); } } } } private List<LyricWord> CreateLyricsLine(string inputText, float startTime, bool isKaraokeLine) { List<LyricWord> words = new List<LyricWord>(); MatchCollection wordMatches = Regex.Matches(inputText, @"\\{\\\\k(\\d+)\\}(\[^{\]+)"); float currentTime = startTime; // Add a temporary TextMeshProUGUI object to measure the text width TextMeshProUGUI tempText = CreateTextObject("", Vector2.zero, false); float currentXPosition = 0; float currentYPosition = 0; float scaleFactor = 2.0f; // Same scale factor as in CreateTextObject() foreach (Match wordMatch in wordMatches) { float wordDuration = float.Parse(wordMatch.Groups\[1\].Value) / 100f; string wordText = wordMatch.Groups\[2\].Value; // Measure the text width tempText.text = wordText; float wordWidth = tempText.preferredWidth \* scaleFactor; // Apply the scale factor // Check if there's enough room left on the current line if (currentXPosition + wordWidth > maxLineWidth) { // Move to the next line currentXPosition = 0; currentYPosition -= tempText.preferredHeight + 10; // Add a small space between the lines } // Create the word object with the calculated anchor position LyricWord word = new LyricWord { text = CreateTextObject(wordText, new Vector2(currentXPosition, currentYPosition), isKaraokeLine), startTime = currentTime, endTime = currentTime + wordDuration }; // Add the word to the list of words words.Add(word); // Update the current time and X position currentTime += wordDuration; currentXPosition += wordWidth; // Add a small space between the words currentXPosition += 10; } // Destroy the temporary TextMeshProUGUI object Destroy(tempText.gameObject); // Calculate the total width of the line float lineWidth = CalculateLineWidth(words, scaleFactor); // Calculate the left padding for each word float leftPadding = (maxLineWidth - lineWidth) / 2; Debug.Log("Left Padding: " + leftPadding); // Update the anchor position for each word with the new left padding foreach (LyricWord word in words) { Vector2 anchorPosition = word.text.rectTransform.anchoredPosition; Debug.Log("Current X Position before padding: " + anchorPosition.x); anchorPosition.x += leftPadding; Debug.Log("Current X Position after padding: " + anchorPosition.x); word.text.rectTransform.anchoredPosition = anchorPosition; } return words; } private float CalculateLineWidth(List<LyricWord> words, float scaleFactor) { float totalWidth = 0; foreach (LyricWord word in words) { totalWidth += word.text.preferredWidth \* scaleFactor; } return totalWidth; } private TextMeshProUGUI CreateTextObject(string wordText, Vector2 anchorPosition, bool isKaraokeLine) { GameObject textObj = new GameObject("Lyric Word"); textObj.transform.SetParent(lyricsParent, false); TextMeshProUGUI text = textObj.AddComponent<TextMeshProUGUI>(); // Set the text properties (font, size, color, etc.) here // Set the maxLineWidth here float maxLineWidth = Screen.width; // Adjust the size of the RectTransform RectTransform rectTransform = text.GetComponent<RectTransform>(); rectTransform.anchorMin = rectTransform.anchorMax = new Vector2(0.5f, 1); rectTransform.sizeDelta = new Vector2(maxLineWidth, 100); // Set the width to the screen width text.color = normalTextColor; text.enableWordWrapping = !isKaraokeLine; // Disable word wrapping for karaoke if (isKaraokeLine) { text.alignment = TextAlignmentOptions.Left; } else { text.alignment = TextAlignmentOptions.Midline; } // Enable outline and set outline width and color text.fontMaterial.EnableKeyword("OUTLINE\_ON"); text.outlineWidth = 0.2f; text.outlineColor = Color.white; // Scale the text float scaleFactor = 2.0f; // Adjust this value to scale the text text.transform.localScale = new Vector3(scaleFactor, scaleFactor, scaleFactor); // Set font style to bold text.fontStyle = FontStyles.Bold; // Set the anchor position rectTransform.anchoredPosition = anchorPosition; Debug.Log("Anchor Position: " + anchorPosition); text.text = wordText; return text; } private IEnumerator SyncLyrics() { int currentLineIndex = 0; // Initially, hide all the words foreach (List<LyricWord> words in lyricsLines) { foreach (LyricWord word in words) { word.text.gameObject.SetActive(false); } } while (audioSource.isPlaying) { float currentTime = audioSource.time; // Display the words when their start times are reached if (currentLineIndex < lineTimestamps.Count && currentTime >= lineTimestamps\[currentLineIndex\]) { foreach (LyricWord word in lyricsLines\[currentLineIndex\]) { word.text.gameObject.SetActive(true); StartCoroutine(HighlightWord(word)); } currentLineIndex++; } // Hide the words when their end times are reached for (int i = 0; i < currentLineIndex; i++) { if (currentTime >= lineEndTimestamps\[i\]) { foreach (LyricWord word in lyricsLines\[i\]) { if (word.text.gameObject.activeSelf) { word.text.gameObject.SetActive(false); } } } } yield return null; } } private IEnumerator HighlightWord(LyricWord word) { yield return new WaitForSeconds(word.startTime - audioSource.time); word.text.color = highlightedTextColor; yield return new WaitForSeconds(word.endTime - word.startTime); word.text.color = normalTextColor; } } I will give you the debug messages in the next message

1 / 1

Sure, I'll be here to help you analyze the debug messages and figure out the issue. Once you provide the debug messages, we can work together to determine what's causing the karaoke lines to be drawn on the left side of the screen and find a solution.

> 1 / 1
> 
> Here are the debug messages: Anchor Position: (0.00, 0.00) UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateTextObject (string,UnityEngine.Vector2,bool) (at Assets/scripts/LyricsSynchronizer.cs:232) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:94) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Anchor Position: (0.00, 0.00) UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateTextObject (string,UnityEngine.Vector2,bool) (at Assets/scripts/LyricsSynchronizer.cs:232) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:116) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Anchor Position: (0.00, 0.00) UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateTextObject (string,UnityEngine.Vector2,bool) (at Assets/scripts/LyricsSynchronizer.cs:232) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:140) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Anchor Position: (219.38, 0.00) UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateTextObject (string,UnityEngine.Vector2,bool) (at Assets/scripts/LyricsSynchronizer.cs:232) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:140) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Anchor Position: (314.80, 0.00) UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateTextObject (string,UnityEngine.Vector2,bool) (at Assets/scripts/LyricsSynchronizer.cs:232) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:140) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Anchor Position: (666.52, 0.00) UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateTextObject (string,UnityEngine.Vector2,bool) (at Assets/scripts/LyricsSynchronizer.cs:232) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:140) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Anchor Position: (741.84, 0.00) UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateTextObject (string,UnityEngine.Vector2,bool) (at Assets/scripts/LyricsSynchronizer.cs:232) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:140) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Anchor Position: (0.00, -50.22) UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateTextObject (string,UnityEngine.Vector2,bool) (at Assets/scripts/LyricsSynchronizer.cs:232) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:140) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Anchor Position: (225.26, -50.22) UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateTextObject (string,UnityEngine.Vector2,bool) (at Assets/scripts/LyricsSynchronizer.cs:232) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:140) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Anchor Position: (360.04, -50.22) UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateTextObject (string,UnityEngine.Vector2,bool) (at Assets/scripts/LyricsSynchronizer.cs:232) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:140) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Left Padding: -217.4901 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:166) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Current X Position before padding: 0 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:172) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Current X Position after padding: -217.4901 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:174) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Current X Position before padding: 219.38 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:172) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Current X Position after padding: 1.889954 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:174) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Current X Position before padding: 314.8 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:172) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Current X Position after padding: 97.30994 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:174) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Current X Position before padding: 666.52 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:172) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Current X Position after padding: 449.03 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:174) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Current X Position before padding: 741.84 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:172) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Current X Position after padding: 524.35 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:174) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Current X Position before padding: 225.26 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:172) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Current X Position after padding: 7.769943 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:174) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Current X Position before padding: 360.04 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:172) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37) Current X Position after padding: 142.5499 UnityEngine.Debug:Log (object) LyricsSynchronizer:CreateLyricsLine (string,single,bool) (at Assets/scripts/LyricsSynchronizer.cs:174) LyricsSynchronizer:LoadLyrics () (at Assets/scripts/LyricsSynchronizer.cs:86) LyricsSynchronizer:Start () (at Assets/scripts/LyricsSynchronizer.cs:37)

1 / 1

From the debug messages, it seems that the text objects are created and positioned correctly on the X-axis, but the Y-axis position remains the same, causing the lyrics to overlap. The issue could be that the `CreateLyricsLine` method is not updating the Y-axis position for each line.

In `LyricsSynchronizer.cs`, find the `CreateLyricsLine` method and make sure the Y-axis position is being updated for each line. You can do this by decrementing the Y-axis position by a constant value (e.g., lineHeight) for each new line:

csharp

```csharp
float lineHeight = 50f; // Adjust this value based on the desired space between lines
currentYPosition -= lineHeight;
```

Include this line of code inside the `CreateLyricsLine` method, after you create the text object for each line.

This should ensure that each line of lyrics is placed below the previous line, avoiding overlap.

> 1 / 1
> 
> no, the issue is that the entire karaoke lines are centred on the left side of the screen. Non-karaoke lines are drawn correctly with the lines of words centres in the middle of the screen horizontally and vertically. Isn't the X position what controls the horizontal? This is the one having issues

1 / 1

I apologize for the confusion. Yes, the X position controls the horizontal positioning. From the debug messages, it appears that the non-karaoke lines are being positioned correctly, but the karaoke lines are not. It seems the issue lies in how the karaoke lines are being horizontally centered.

To fix this, you should adjust the X position for the karaoke lines inside the `CreateLyricsLine` method in `LyricsSynchronizer.cs`. First, calculate the total width of the line and use it to adjust the X position accordingly.

Here's how you can modify the `CreateLyricsLine` method:

csharp

```csharp
private void CreateLyricsLine(string lineText, float time, bool isKaraoke)
{
    // Your existing code

    // Calculate the total width of the line
    float lineWidth = 0;
    foreach (GameObject word in words)
    {
        lineWidth += word.GetComponent<RectTransform>().sizeDelta.x;
    }

    // Calculate the padding needed to center the line
    float leftPadding = (canvasWidth - lineWidth) / 2;

    // Update the X position of each word in the line
    for (int i = 0; i < words.Count; i++)
    {
        RectTransform wordRect = words[i].GetComponent<RectTransform>();
        wordRect.anchoredPosition = new Vector2(wordRect.anchoredPosition.x + leftPadding, wordRect.anchoredPosition.y);
    }

    // Your existing code
}
```

This code calculates the total width of the line, computes the left padding required to center the line, and then updates the X position of each word in the line accordingly. This should center the karaoke lines correctly on the screen.

> 1 / 1
> 
> Now I get this error: Assets\\scripts\\LyricsSynchronizer.cs(163,9): error CS0030: Cannot convert type 'LyricsSynchronizer.LyricWord' to 'UnityEngine.GameObject' Assets\\scripts\\LyricsSynchronizer.cs(169,30): error CS0103: The name 'canvasWidth' does not exist in the current context Assets\\scripts\\LyricsSynchronizer.cs(174,47): error CS1061: 'LyricsSynchronizer.LyricWord' does not contain a definition for 'GetComponent' and no accessible extension method 'GetComponent' accepting a first argument of type 'LyricsSynchronizer.LyricWord' could be found (are you missing a using directive or an assembly reference?) Here's the code for reference: using UnityEngine; using TMPro; using System.Collections; using System.Collections.Generic; using System.Text.RegularExpressions; public class LyricsSynchronizer : MonoBehaviour { public RectTransform lyricsParent; public AudioClip audioClip; public string lyricsFileName = "Never-Gonna-Poop-You-Up-Lyrics"; public Color normalTextColor = Color.black; public Color highlightedTextColor = Color.yellow; private AudioSource audioSource; private List<List<LyricWord>> lyricsLines = new List<List<LyricWord>>(); private List<float> lineEndTimestamps = new List<float>(); private float maxLineWidth; private class LyricWord { public TextMeshProUGUI text; public float startTime; public float endTime; } private void Start() { maxLineWidth = Screen.width; lyricsParent.anchorMin = lyricsParent.anchorMax = new Vector2(0.5f, 0.5f); lyricsParent.pivot = new Vector2(0.5f, 0.5f); lyricsParent.anchoredPosition = Vector2.zero; // Load lyrics from the text file LoadLyrics(); audioSource = gameObject.AddComponent<AudioSource>(); audioSource.clip = audioClip; audioSource.Play(); StartCoroutine(SyncLyrics()); } private List<float> lineTimestamps = new List<float>(); private void LoadLyrics() { TextAsset lyricsFile = Resources.Load<TextAsset>(lyricsFileName); string\[\] lines = lyricsFile.text.Split('\\n'); for (int i = 0; i < lines.Length; i++) { if (lines\[i\].StartsWith("Dialogue:")) { string\[\] parts = lines\[i\].Split(','); // Parse the start timestamp string\[\] startTimeParts = parts\[1\].Split(':'); float startHours = float.Parse(startTimeParts\[0\]); float startMinutes = float.Parse(startTimeParts\[1\]); float startSeconds = float.Parse(startTimeParts\[2\]); float startTimestamp = startHours \* 3600 + startMinutes \* 60 + startSeconds; // Parse the end timestamp string\[\] endTimeParts = parts\[2\].Split(':'); float endHours = float.Parse(endTimeParts\[0\]); float endMinutes = float.Parse(endTimeParts\[1\]); float endSeconds = float.Parse(endTimeParts\[2\]); float endTimestamp = endHours \* 3600 + endMinutes \* 60 + endSeconds; // Add the start and end timestamps to the lists lineTimestamps.Add(startTimestamp); lineEndTimestamps.Add(endTimestamp); // Get the lyrics line text string lyricsLineText = Regex.Match(lines\[i\], @"(?<=^\[^,\]\*(?:,\[^,\]\*){8},).\*$").Value.Trim(); // Check if the line has karaoke mode if (Regex.IsMatch(lyricsLineText, @"\\{\\\\k\\d+\\}")) { // Remove formatting tags (like "{\\k30}") from the text string plainText = Regex.Replace(lyricsLineText, @"\\{\[^}\]\*\\}", ""); // For karaoke lines List<LyricWord> words = CreateLyricsLine(lyricsLineText, startTimestamp, true); // Add the words to the list of lyrics lines lyricsLines.Add(words); } else { // If the line doesn't have karaoke mode, create a single LyricWord for the entire line LyricWord word = new LyricWord { text = CreateTextObject(lyricsLineText, Vector2.zero, false), startTime = startTimestamp, endTime = endTimestamp }; // Add the word to the list of lyrics lines lyricsLines.Add(new List<LyricWord> { word }); } } } } private List<LyricWord> CreateLyricsLine(string inputText, float startTime, bool isKaraokeLine) { List<LyricWord> words = new List<LyricWord>(); MatchCollection wordMatches = Regex.Matches(inputText, @"\\{\\\\k(\\d+)\\}(\[^{\]+)"); float currentTime = startTime; // Add a temporary TextMeshProUGUI object to measure the text width TextMeshProUGUI tempText = CreateTextObject("", Vector2.zero, false); float currentXPosition = 0; float currentYPosition = 0; float scaleFactor = 2.0f; // Same scale factor as in CreateTextObject() foreach (Match wordMatch in wordMatches) { float wordDuration = float.Parse(wordMatch.Groups\[1\].Value) / 100f; string wordText = wordMatch.Groups\[2\].Value; // Measure the text width tempText.text = wordText; float wordWidth = tempText.preferredWidth \* scaleFactor; // Apply the scale factor // Check if there's enough room left on the current line if (currentXPosition + wordWidth > maxLineWidth) { // Move to the next line currentXPosition = 0; currentYPosition -= tempText.preferredHeight + 10; // Add a small space between the lines } // Create the word object with the calculated anchor position LyricWord word = new LyricWord { text = CreateTextObject(wordText, new Vector2(currentXPosition, currentYPosition), isKaraokeLine), startTime = currentTime, endTime = currentTime + wordDuration }; // Add the word to the list of words words.Add(word); // Update the current time and X position currentTime += wordDuration; currentXPosition += wordWidth; // Add a small space between the words currentXPosition += 10; } // Destroy the temporary TextMeshProUGUI object Destroy(tempText.gameObject); // Calculate the total width of the line float lineWidth = 0; foreach (GameObject word in words) { lineWidth += word.GetComponent<RectTransform>().sizeDelta.x; } // Calculate the padding needed to center the line float leftPadding = (canvasWidth - lineWidth) / 2; // Update the X position of each word in the line for (int i = 0; i < words.Count; i++) { RectTransform wordRect = words\[i\].GetComponent<RectTransform>(); wordRect.anchoredPosition = new Vector2(wordRect.anchoredPosition.x + leftPadding, wordRect.anchoredPosition.y); } // Calculate the left padding for each word //float leftPadding = (maxLineWidth - lineWidth) / 2; Debug.Log("Left Padding: " + leftPadding); // Update the anchor position for each word with the new left padding foreach (LyricWord word in words) { Vector2 anchorPosition = word.text.rectTransform.anchoredPosition; Debug.Log("Current X Position before padding: " + anchorPosition.x); anchorPosition.x += leftPadding; Debug.Log("Current X Position after padding: " + anchorPosition.x); word.text.rectTransform.anchoredPosition = anchorPosition; } return words; } private float CalculateLineWidth(List<LyricWord> words, float scaleFactor) { float totalWidth = 0; foreach (LyricWord word in words) { totalWidth += word.text.preferredWidth \* scaleFactor; } return totalWidth; } private TextMeshProUGUI CreateTextObject(string wordText, Vector2 anchorPosition, bool isKaraokeLine) { GameObject textObj = new GameObject("Lyric Word"); textObj.transform.SetParent(lyricsParent, false); TextMeshProUGUI text = textObj.AddComponent<TextMeshProUGUI>(); // Set the text properties (font, size, color, etc.) here // Set the maxLineWidth here float maxLineWidth = Screen.width; // Adjust the size of the RectTransform RectTransform rectTransform = text.GetComponent<RectTransform>(); rectTransform.anchorMin = rectTransform.anchorMax = new Vector2(0.5f, 1); rectTransform.sizeDelta = new Vector2(maxLineWidth, 100); // Set the width to the screen width text.color = normalTextColor; text.enableWordWrapping = !isKaraokeLine; // Disable word wrapping for karaoke if (isKaraokeLine) { text.alignment = TextAlignmentOptions.Left; } else { text.alignment = TextAlignmentOptions.Midline; } // Enable outline and set outline width and color text.fontMaterial.EnableKeyword("OUTLINE\_ON"); text.outlineWidth = 0.2f; text.outlineColor = Color.white; // Scale the text float scaleFactor = 2.0f; // Adjust this value to scale the text text.transform.localScale = new Vector3(scaleFactor, scaleFactor, scaleFactor); // Set font style to bold text.fontStyle = FontStyles.Bold; // Set the anchor position rectTransform.anchoredPosition = anchorPosition; Debug.Log("Anchor Position: " + anchorPosition); text.text = wordText; return text; } private IEnumerator SyncLyrics() { int currentLineIndex = 0; // Initially, hide all the words foreach (List<LyricWord> words in lyricsLines) { foreach (LyricWord word in words) { word.text.gameObject.SetActive(false); } } while (audioSource.isPlaying) { float currentTime = audioSource.time; // Display the words when their start times are reached if (currentLineIndex < lineTimestamps.Count && currentTime >= lineTimestamps\[currentLineIndex\]) { foreach (LyricWord word in lyricsLines\[currentLineIndex\]) { word.text.gameObject.SetActive(true); StartCoroutine(HighlightWord(word)); } currentLineIndex++; } // Hide the words when their end times are reached for (int i = 0; i < currentLineIndex; i++) { if (currentTime >= lineEndTimestamps\[i\]) { foreach (LyricWord word in lyricsLines\[i\]) { if (word.text.gameObject.activeSelf) { word.text.gameObject.SetActive(false); } } } } yield return null; } } private IEnumerator HighlightWord(LyricWord word) { yield return new WaitForSeconds(word.startTime - audioSource.time); word.text.color = highlightedTextColor; yield return new WaitForSeconds(word.endTime - word.startTime); word.text.color = normalTextColor; } }

1 / 1

I apologize for the confusion in my previous response. Please find the corrected code with explanations for the changes below:

1.  Replace `GameObject` with `LyricWord` in the foreach loop.
2.  Replace `word.GetComponent<RectTransform>()` with `word.text.rectTransform` since `LyricWord` objects do not have a `GetComponent` method. We can directly access the `RectTransform` through the `text` field.
3.  Define `canvasWidth` as a local variable in the `CreateLyricsLine` method.

Here's the modified `CreateLyricsLine` method:

csharp

```csharp
private List<LyricWord> CreateLyricsLine(string inputText, float startTime, bool isKaraokeLine)
{
    // Your existing code

    // Calculate the total width of the line
    float lineWidth = 0;
    foreach (LyricWord word in words) // Change GameObject to LyricWord
    {
        lineWidth += word.text.rectTransform.sizeDelta.x; // Access rectTransform directly
    }

    // Calculate the padding needed to center the line
    float canvasWidth = lyricsParent.rect.width; // Define canvasWidth
    float leftPadding = (canvasWidth - lineWidth) / 2;

    // Update the X position of each word in the line
    for (int i = 0; i < words.Count; i++)
    {
        RectTransform wordRect = words[i].text.rectTransform; // Access rectTransform directly
        wordRect.anchoredPosition = new Vector2(wordRect.anchoredPosition.x + leftPadding, wordRect.anchoredPosition.y);
    }

    // Your existing code
}
```

With these changes, the code should compile without errors and the karaoke lines should be horizontally centered correctly.

> 1 / 1
> 
> Okay now the karaoke lines are not drawn on screen at all, only the non-karaoke lines are drawn

1 / 1

Apologies for the confusion. It appears that the RectTransform is not being set up correctly in the CreateTextObject method, causing the karaoke lines to be hidden. Let's fix this by modifying the RectTransform settings in the CreateTextObject method.

Replace the following lines of code in the CreateTextObject method:

csharp

```csharp
RectTransform rectTransform = text.GetComponent<RectTransform>();
rectTransform.anchorMin = rectTransform.anchorMax = new Vector2(0.5f, 1);
rectTransform.sizeDelta = new Vector2(maxLineWidth, 100); // Set the width to the screen width
```

with:

csharp

```csharp
RectTransform rectTransform = text.GetComponent<RectTransform>();
rectTransform.anchorMin = new Vector2(0, 1);
rectTransform.anchorMax = new Vector2(0, 1);
rectTransform.pivot = new Vector2(0, 1);
rectTransform.sizeDelta = new Vector2(maxLineWidth, 100); // Set the width to the screen width
```

These changes will correctly position the RectTransform based on the top-left corner, making sure that the karaoke lines are visible on the screen.

> 1 / 1
> 
> doesn't the same code apply to karaoke lines and non-karaoke lines? Can you explain why this would solve the issue?

1 / 1

You're right. I apologize for the confusion; my previous response was not accurate. Upon closer inspection of the code, it seems like the issue might be related to the activation and deactivation of the words in the SyncLyrics() method. Let's try an alternative approach to fix this issue.

First, remove the following lines from the SyncLyrics() method:

csharp

```csharp
// Initially, hide all the words
foreach (List<LyricWord> words in lyricsLines)
{
    foreach (LyricWord word in words)
    {
        word.text.gameObject.SetActive(false);
    }
}
```

Instead of hiding the words initially, we will set their color to transparent. Modify the CreateTextObject() method, replacing:

csharp

```csharp
text.color = normalTextColor;
```

with:

csharp

```csharp
text.color = new Color(normalTextColor.r, normalTextColor.g, normalTextColor.b, 0);
```

This change will set the initial color of the words to be transparent.

Now, in the SyncLyrics() method, replace:

csharp

```csharp
word.text.gameObject.SetActive(true);
```

with:

csharp

```csharp
word.text.color = new Color(normalTextColor.r, normalTextColor.g, normalTextColor.b, 1);
```

And replace:

csharp

```csharp
word.text.gameObject.SetActive(false);
```

with:

csharp

```csharp
word.text.color = new Color(normalTextColor.r, normalTextColor.g, normalTextColor.b, 0);
```

These changes will update the alpha value of the text color to make the words visible or invisible, instead of activating or deactivating the GameObjects.

Try running the code again and see if the karaoke lines are now displayed correctly on the screen.